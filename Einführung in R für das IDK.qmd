---
title: Einführung in R für das IDK
author: Lorenz Biberstein
institute: Institut für Delinquenz und Kriminalprävention, ZHAW
date: last-modified
date-format: "D. MMMM YYYY"
format:
  html:
    embed-resources: true
    df-print: kable
  pdf: default
always_allow_html: paged
toc: true
toc-depth: 5
toc-title: "Inhalt"
toc-location: left
number-sections: true
number-depth: 3
lang: "de-DE"
bibliography: references.bib
csl: apa.csl
---

::: callout-warning
## Bemerkung

Diese Einleitung und Übersicht wird laufend ergänzt. Bitte melden bei bibs\@zhaw.ch, wenn etwas falsch oder unverständlich ist, fehlt oder ergänzt werden sollte.
:::

# Einleitung

```{r}
#| echo: false
#| warning: false
library(here) # Für saubere Pfade
library(readr) # Import von Daten in versch. Formaten
library(readxl) # Import von Excel
library(ggplot2) # Schöne Abbildungen
library(vtable) # Beschreibung von Daten
library(janitor) # Für schöne Tabellen
library(haven) # Import von SPSS, Stata etc.
library(downloadthis) # Für Herunterladen von Datensätzen aus dem html-Output
library(expss) # Für SPSS-ähnliche Tabellen
library(tidylog, warn.conflicts = FALSE) # Für direkte Protokolle von Funktionen aus dem tidyverse
library(conflicted) # Für Hilfe mit Paket-Konflikten
```

```{r setting}
#| echo: false
#| warning: false
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE
)
```

## Vorbereitung

Dies ist eine kurze Einleitung in R und RStudio für das IDK. Zur Einleitung gehören die folgenden Dateien:

-   R-Skript mit Beispielcode: "Einführung in R für das IDK - Codes.R"
-   Datensätze in verschiedenen Formaten (im gezippten Ordner "Daten"):
    -   "Alpenquerender_Gueterverkehr_Schiene.xlsx"
    -   "Arrivals.txt"
    -   "car_sales.sav"
    -   "Churn.csv"
    -   "Treibstoffpreise_CH.rda"
    -   shiny-Demo: "app.R"

Als Vorbereitung bitte die folgenden Schritte ausführen:

1.  R und RStudio installieren (@sec-rstudio)
2.  RStudio starten und ein Projekt eröffnen (@sec-projekte), z.B. mit Namen "Einführung R" in einem Ordner / einem Ort eurer Wahl
3.  In diesem Projektordner zwei Unterordner anlegen: "Daten" und "Datenexport"
4.  Die gezippten Daten im Unterordner "Daten" entzippen und ablegen
5.  Das R-Skript "Einführung in R für das IDK - Codes.R" und diese Anleitung ("Einführung in R für das IDK.html") im Projektordner ablegen

## R und RStudio {#sec-rstudio}

-   Basisprogramm ist R
-   Benutzt wird es aber meistens über RStudio (angenehmere Oberfläche)
-   Installieren aus Software Center: Zuerst R (muss später nie mehr geöffnet werden), dann RStudio (@fig-rstudio-softwarecenter)

![R und RStudio im Software Center](images/Screenshot.png){#fig-rstudio-softwarecenter}

![Layout RStudio](images/Screenshot%20(58).png){#fig-layout-rstudio}

::: callout-tip
Empfehlung: R und RStudio am Arbeits-Laptop immer über das Software Center installieren, um Versionsprobleme zu vermeiden.
:::

-   RStudio ist unterteilt in verschiedene Fenster (die sich unterschiedlich anordnen lassen, Farbe und Schrift lassen sich ebenfalls anpassen, siehe @fig-layout-rstudio)
-   Am wichtigsten:
    -   Skript (hier oben links, analog SPSS-Syntax oder do-File in STATA)
    -   Konsole für freie Eingabe von Code und Output von Analysen (unten links)
    -   Geladene Daten & Objekte in der Umgebung (Tab "Environment"; oben rechts)
    -   Projektordner (Tab "Files"; unten rechts)
    -   Abbildungen (Tab "Plots"; unten rechts)
    -   Verlauf der bisherigen Anwendungen (Tab "History"; oben rechts): Bereits benutzte Befehle können aus der History kopiert werden, z.B. direkt in die Konsole ("To Console") oder in ein Skript ("To Source").
-   User Guide für RStudio: <https://docs.posit.co/ide/user/>

## Projekte {#sec-projekte}

-   Sehr zu empfehlen: Projekt anlegen für verschiedene Analysen
-   "File" -\> "New Project" oder oben rechts auf "Project: (None)" -\> "New Project"
    -   Auswahl aus verschiedenen Ablagemöglichkeiten. Am einfachsten: "New Directory" (@fig-new-project).
    -   Falls mit Versionskontrolle gearbeitet wird (siehe @sec-github): "Version Control"
    -   Unter "Project Type" ebenfalls "New Project" wählen
    -   Unter "Directory name:" dem Projekt einen Namen geben und unter "Create project as subdirectory of:" den Speicherort für den Projektordner auswählen (@fig-new-project-name-path).

![Neues Projekt eröffnen: Projekt eröffnen](images/Screenshot%20(39).png){#fig-new-project alt="Neues Projekt eröffnen"}

![Neues Projekt eröffnen: Verzeichnisname und Speicherort](images/Screenshot%20(69).png){#fig-new-project-name-path}

-   Vorteile:
    -   Ein Hauptordner für ganzes Projekt
    -   R kann Einstellung pro Projekt speichern
    -   R weiss, welche Skripte, Dateien etc. zu welchem Projekt gehören
    -   In RStudio von Projekt zu Projekt wechseln, vereinfacht Organisation
-   Best practice: Sauber getrennte Unterordner für Daten, Analysen, Abbildungen, Bericht etc.

::: callout-important
Pfade à la "`C:\Users\bibs\OneDrive - ZHAW\R\Einführung in R für das IDK`" sind **verpönt**, weil nicht anwendbar auf anderen Geräte / für andere Benutzer.
:::

-   Allgemein gültige Pfade mit dem Paket {here} [@here] -\> laden am Anfang mit `library(here)`
    -   R weiss dann "`here() starts at C:/Users/bibs/OneDrive - ZHAW/R/Einführung in R für das IDK`" und startet im Projektordner (der irgendwo abgelegt werden kann)
    -   Daten einlesen z.B. mit `Churn <- read_table(here("Daten", "Churn.csv"))` funktioniert für alle Personen, solange sie in ihrem Hauptprojektordner einen Unterordner "Daten" haben, in dem die Daten "Churn.csv" abgelegt sind.

## Kleinere Unterschied zu SPSS

-   Neben Skripten (analog zu SPSS-Syntax) gibt es eine Konsole (für freie Eingabe)
-   Praktisch keine Menuführung für Analysen (Ausnahme: Erweiterung für Abbildungen, siehe @sec-esquisse)
-   R ist case sensitive! "x" ist nicht das gleiche wie "X"!
-   Es gibt nicht wie in SPSS versch. Fenster für Syntax, Output und Daten, sondern alles ist in einem Fenster (Ausnahmen sind möglich, z.B. zusätzliches Fenster für Abbildungen)
-   Keine Variablenansicht, nur Datenansicht mit `View()`

## Base R vs. Pakete ("libraries") {#sec-pakete}

-   Basisinstallation ist "Base R" ({base}; [-@base]); kommt bereits mit sehr vielen Anwendungen
-   Weitere bereits installierte Erweiterungen (keine eigenständigen Pakete, die getrennt installiert werden können):
    -   {stats} für statistische Anwendungen
    -   {graphics} für einfache Abbildungen
-   Verschiedene mehr oder weniger spezielle Anwendungen benötigen aber spezielle Pakete
-   Paket installieren (nur beim ersten Mal): `install.packages("name-des-pakets")`
-   Paket laden für Nutzung: `library(name-des-pakets)` (Keine Anführungszeichen nötig)
-   Achtung, wenn verschiedene Pakete *Funktionen mit gleichem Namen* verwenden (@fig-conflicting-functions)

![Konflikte bei der Funktion "filter()", die im Paket {dplyr} und im Paket {stats} vorkommt, ebenso "lag()"](images/Screenshot%20(44).png){#fig-conflicting-functions}

-   Dann muss ggf. das Paket mit zwei Doppelpunkten vorangestellt werden (R zeigt beim laden der beiden fraglichen Pakete an, welche Funktion aus welchem Paket benutzt wird, eine "überlager" die andere):
    -   `dplyr::filter()`
    -   `stats::filter()`
-   Das {conflicted}-Paket @conflicted hilft bei Konflikten, indem es die Konflikte explizit benennt und Lösungen vorschlägt.

::: callout-caution
Die Ausführung von nicht eindeutigen Befehlen wird angehalten, wenn das {conflicted}-Paket geladen ist!
:::

-   Unterschied zu SPSS: Dort gibt es keine verschiedenen Pakete, alle Funktionen sind für SPSS klar und eindeutig.
-   Einige Funktionen kommen auch identisch in verschiedenen Paketen vor!

::: callout-caution
Mit jedem benutzten Paket können Abhängigkeiten entstehen (einige Pakete benötigen wiederum andere Pakete), im Extremfall funktioniert ein Paket plötzlich nicht mehr oder der Code, den man beim letzten Mal benutzt hat, funktioniert anders (für diese spezifischen Herausforderungen bei der Reproduzierbarkeit gibt es wiederum eigene Lösungen...).
:::

-   Bei grossen, viel benutzten und gut unterhaltenen Paketen ist das aber selten ein Problem.
-   Pakete, die auf CRAN ("The Comprehensive R Archive Network", <https://cran.r-project.org/web/packages/available_packages_by_name.html>) sind, haben eine gewisse Qualitätskontrolle durchlaufen. Diese können mit `install.packages()` installiert werden. Es lassen sich aber auch individuelle Pakete installieren, die nicht auf CRAN sind (jede:r kann / darf ein R-Paket schreiben), dies ist dann etwas komplizierter.
-   Eine (zugänglichere) Einführung in die Welt der Pakete findet sich z.B. bei @ooms2023a, eine Übersichtssuche findet sich hier: <https://r-universe.dev/search/>

# Daten in R

## Objekte {#objekte}

R kann verschiedene Daten(sätze) als Objekte *gleichzeitig laden* (oben rechts in "Environment"; @fig-environment-list und @fig-environment-grid, je nach Darstellung), diese können *verschiedene Typen* sein:

-   Klassische Datensätze mit Fällen in Zeilen und Variablen in Spalten ("data frame" genannt in RStudio, hier z.B. "alpenquer", "Arrivals", "car_sales", "Churn")[^1]
-   Matrizen (z.B. unten "m"; Matrizen haben immer gleichen Datentyp in den Spalten, data frames können verschiedene Daten haben (numerisch, string, logisch, faktoren))
-   Vektoren von mehreren Zahlen (z.B. unten "y")
-   Nur ein einzelner Wert (z.B. "sepal_length_mean" oder "x")
-   Liste von Werten, die im Gegensatz zu Vektoren genauer spezifiziert sind (z.B. Resultate von Analysen mit Koeffizienten, Parameter etc., z.B. "fit-iris")

[^1]: Erweiterungen des klassischen data frames aus {base} R sind "tibbles" im tidyverse-Universum (siehe @sec-tidyverse), oder "data.tables" bei Benutzung vom Paket {data.table} (siehe @data.table oder <https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html>)

![Environment mit verschiedenen geladenen Objekten; Ansicht "List"](images/Screenshot%20(61).png){#fig-environment-list}

![Environment mit verschiedenen geladenen Objekten; Ansicht "Grid"](images/Screenshot%20(62).png){#fig-environment-grid}

-   Befehle müssen deshalb die zu benutzenden Objekte *eindeutig identifizieren:*
    -   Objekte und ihre Elemente werden mit `$` voneinander getrennt
    -   Z.B. bezieht sich`iris$Sepal.Width` auf die Variable "Sepal.Width" im Datensatz "iris", `ToothGrowth$len` auf die Variable "len" im Datensatz "ToothGrowth" etc.
-   In einer Anwendung können Variablen aus verschiedenen Datensätzen kombiniert werden, ohne dass die Datensätze kombiniert werden müssen, z.B. berechnet `mean(iris$Sepal.Width) + mean(ToothGrowth$len)` die Summe der Mittelwerte der Variable "Sepal.Width" aus dem Datensatz "iris" und der Variable "len" aus dem Datensatz "ToothGrowth".
-   Nachfolgend wird der Platzhalter `df` für einen Datensatz verwendet ("data frame"), z.B. `mean(df$Var1)`.

## Importieren von Daten

-   Für uns sind am ehesten "klassische" Datensätze relevant - Spalten sind Variablen und Zeilen sind Beobachtungen / Fälle
-   Je nach Dateiformat sind zum Import Pakete notwendig (oder zumindest hilfreich)
-   Manuell / quick and dirty: Unten rechts unter "Files" den entsprechenden Ablageordner suchen -\> Klicken auf den Datensatz -\> "Import dataset" (@fig-datenimport-menu) oder oben links auf "File" -\> "Import dataset".
-   Oder - besser (Reproduzierbarkeit!) - via Code (ggf. aus dem Importmenu kopieren): Unterschiedlich je nach Datenformat.

![Datenimport eines CSV via Menu](images/image-874524877.png){#fig-datenimport-menu}

-   Viele Daten lassen sich mit bestehenden (base R) Funktionen laden, z.B. `read.csv()` für CSV oder `read.table()` für Tabellen (Excel).
-   Es gibt neben den bestehenden Funktionen auch andere, wie {readr} [@readr] für Textdokumente oder {readxl} [@readxl] für Excel-Tabellen, welche das gleiche Ziel haben (Datenimport), aber ggf. andere Einstellungsmöglichkeiten haben oder Daten automatisiert erkennen.
-   Spezielle Formate brauchen ggf. spezielle Pakete, wie {haven} [@haven] für den Import von SPSS- oder STATA-Daten.

::: callout-caution
R geht mit Labels ganz anders um, diese können ggf. nicht importiert werden (siehe @sec-kategoriale-variablen)!
:::

-   Es gibt auch einige R-spezifische Datenformate:
    -   Bereits in R bestehenden Daten: `data("name")`; ohne Zuweisung an Objekt
    -   Ein einzelnes Objekt ".rds": `readRDS("name.rds")`; braucht Zuweisung an Objekt
    -   Mehrere Objekte möglich: ".rda" oder ".Rdata": `load("name.rda")`; ohne Zuweisung an Objekt, bei diesen ist der Objektname bereits hinterlegt

```{r, echo = TRUE}
# csv
Churn <- readr::read_table(here("Daten", "Churn.csv"))

# txt
Arrivals <- readr::read_table(here("Daten", "Arrivals.txt"))

# Excel
alpenquer <- readxl::read_excel(here("Daten", "Alpenquerender_Gueterverkehr_Schiene.xls"))

# rda (eigenes R-Format)
load(here("Daten", "Treibstoffpreise_CH.rda"))

# Import von SPSS
car_sales <- haven::read_spss(here("Daten", "car_sales.sav"))

# Laden von in R bestehenden Daten
# Müssen keinem Objekt mehr zugewiesen werden!
data("iris")
data("USArrests")
data("AirPassengers") # Spezialfall Zeitreihe
```

-   Man beachte, dass in den Daten "USArrests" die Fälle benannt / beschriftet sind (`View(USArrests)`), ohne dass die Information in einer Variable gespeichert ist. In "iris" sind die Daten einfach nummeriert.

## Daten anschauen, ersten Überblick gewinnen

Wollen die Daten visuell untersucht werden, gibt es verschiedene Möglickeiten:

-   `View(df)`: Öffnet die Daten als Tabelle, analog der Datenansicht in SPSS. Eine Bearbeitung der Daten ist *nicht* möglich, lediglich eine Sortierung in den Spalten.

-   Alternative zu `View(df)`: Oben rechts in "Environment" auf die Daten klicken.

-   `head(df)`: Zeigt die ersten Einträge der Daten in der Konsole (mit `head(df, x)` kann die Anzahl Zeilen `x` definiert werden), die angezeigt werden sollen. Je nach Anzahl Variablen haben nicht alle Spalten Platz in der Anzeige.

-   `tail(df)`: Analog `head(df)`, einfach die letzten Einträge in den Daten.

-   `summary(df)`: Deskriptive Statistiken aller Variabeln im Datensatz (bei kategorialen Variablen die Häufigkeit, bei metrischen Variablen Minimum, Median, Mittelwert, Maximum und Quartile). Für deskriptive Statistiken einer einzelnen Variable: `summary(df$Var1)`.

-   `dplyr::glimpse(df)`: Funktion aus dem {dplyr}-Paket (aus dem tidyverse, siehe @sec-tidyverse). Zeigt etwas mehr Daten an, dazu auch das Format der einzelnen Variablen (nicht zu verwechseln mit den Klassen, siehe @sec-variablentypen!)

-   Weiteres zu deskriptiven Analysen im @sec-deskriptive-statistiken.

## Exportieren / Speichern von Daten

-   Ich speichere fast nie bearbeitete Daten, sondern finde es einfacher, Rohdaten zu laden und das Skript darüber laufen zu lassen.
-   Export möglich in .csv, .xlsx oder ggf. in SPSS- oder STATA-Format mit {haven}
-   Export in R-Formate wie `.Rds` oder `.Rdata` / `.rda` (identisch, aber die Endung `.Rdata` wird von Windows als zu R gehörend automatisch erkannt, `.rda` nicht. Ich würde deshalb `.Rdata` empfehlen).
-   Idealerweise auch wieder das {here}-Paket benutzen (s. oben) für saubere Pfade

::: callout-caution
Ein allfälliger Unterordner muss schon bestehen für den Export darin
:::

-   Nb: Falls RStudio fragt, ob der Workspace gesichert werden soll: Immer "Nein" klicken, sonst lädt man beim nächsten Mal bearbeitete Daten in den Workspace und weiss nicht mehr, wie diese bearbeitet wurden.

```{r}
# Einzelnen Datensatz speichern im .Rds-Format
saveRDS(Churn, here("Datenexport", "Churn_save.Rds"))

# Mehrere geladenen Daten speichern im .Rdata-Format
save(list = c("Churn", "Arrivals"), 
     # Objekte "Churn" und "Arrivals" werden exportiert
     file = here("Datenexport/Churn_Arrivals.Rdata"))
# Beim Export in .Rdata braucht es den Zusatz "file = ..." 

# Exportieren in SPSS-Format
haven::write_sav(iris, here("Datenexport", "iris.sav"))
```

## Variablentypen / -klassen {#sec-variablentypen}

-   R speichert Werte / Inhalte von Variablen in den folgenden Typen ("classes")
    -   "*num*": Numerisch (Zahlen, Standard, alle reellen Zahlen)
    -   "*int*": Numerisch (Zahlen; integer, nur ganzzahlige Werte)
    -   "*chr*": character (Buchstaben, String in SPSS)
    -   "*factor*": Kategoriale Variablen (ordinal skalierte Variablen, siehe @sec-kategoriale-variablen)
    -   "*logi*": logical (TRUE / FALSE)
    -   "*POSIXct* oder *POSIXt*": Datumsformat von R
    -   "*ts*": Zeitreihe (time series, eigenes spezifisches Format in R)
-   Datentyp (je nachdem) abfragen mit `class(),` `str()` oder `summary()` oder oben rechts in "Environment" anschauen...

# Erste Arbeiten in R

-   Funktionen werden immer mit einer Klammer am Ende geschrieben, ohne schliessende Klammer geht nichts...
-   Innerhalb von Klammern können weitere Funktionen geschrieben werden (s. unten)
-   Code ausführen:
    -   Code markieren, ganze Zeile auswählen oder einfach in den Code klicken
    -   Ausführen entweder mit *Ctrl + Enter*
    -   Oder in Konsole individuell mit *Enter*
    -   Oder oben rechts im Skript auf "Run"
    -   Letzte Befehle aus der Konsole scrollen mit *Shift + Pfeil nach oben* oder im Fenster oben rechts auf "History"

::: callout-tip
## Ausführen von Teil-Code

Teil eines längeren Codes markieren und mit *Ctrl + Enter* ausführen, bspw. ergibt `round(sqrt(122))` 11, ich kann aber auch nur `sqrt(122)` markieren und mit *Ctrl + Enter* ausführen, dann erhalte ich die ungerundete Zahl.
:::

## Mathematische Operatoren und logische Operatoren {#sec-log-operatoren}

-   Die mathematischen Operatoren können normal benutzt werden, wie man sie kennt [@navarro, S. 46]

| Anwendung      | Operator | Beispieleingabe | Beispielausgabe |
|----------------|----------|-----------------|-----------------|
| Addition       | `+`      | `10 + 2`        | `12`            |
| Subtraktion    | `-`      | `9 - 3`         | `6`             |
| Multiplikation | `*`      | `5 * 5`         | `25`            |
| Division       | `/`      | `9 / 3`         | `3`             |
| Potenz         | `^`      | `5 ^ 2`         | `25`            |

: Mathematische Operatoren {#tbl-mathematische-operatoren}

-   Die logischen Operatoren sind nicht immer gleich wie in SPSS [@navarro, S. 63-64]!
    -   (Eingabe des "Oder" (`|`) mit *Ctrl + Alt + 7*)

| Anwendung      | Operator | Beispieleingabe   | Antwort |
|----------------|----------|-------------------|---------|
| Kleiner als    | `<`      | `2 < 3`           | `TRUE`  |
| Kleiner gleich | `<=`     | `2 <= 2`          | `TRUE`  |
| Grösser als    | `>`      | `2 > 3`           | `FALSE` |
| Grösser gleich | `>=`     | `2 <= 2`          | `TRUE`  |
| Gleich         | `==`     | `2 == 3`          | `FALSE` |
| Ungleich       | `!=`     | `2 != 3`          | `TRUE`  |
| (Ist) Nicht    | `!`      | `!(1==1)`         | `FALSE` |
| Oder           | `|`      | `(1==1) | (2==3)` | `TRUE`  |
| Und            | `&`      | `(1==1) & (2==3)` | `FALSE` |

: Logische Operatoren {#tbl-logische-operatoren}

## Einfache Eingabe und Zuweisung an *Objekte* {#sec-objekte}

-   Normale Eingabe von Code in Konsole

```{r, echo = TRUE}
1 + 2
```

-   Zuweisung an ein Objekt mit Pfeil `<-`, egal ob ein direkter Wert oder das Resultat einer Berechnung

```{r, echo = TRUE}
a <- 9
a

x <- 1 + 2
x
```

-   Benutzung des Objekts "x"

```{r, echo = TRUE}
x + 4
```

-   Es kann auch Text an ein Objekt zugewiesen werden

```{r}
farbe <- "rosa"
farbe
```

-   Zahlen können an beliebige Objekte zugewiesen werden, um mit ihnen zu rechnen. Hier werden zwei Zahlen unter `Erste_Zahl` und `Zweite_Zahl` gespeichert

```{r}
Erste_Zahl <- 4
Zweite_Zahl <- 5

Erste_Zahl * Zweite_Zahl
```

-   Objekte können **nicht** als Zahlen benannt werden!

```{r}
# 1 <- 2
# Error in 1 <- 2 : invalid (do_set) left-hand side to assignment
```

## Komplizierteres

-   Eingabe mehrerer Werte als *Vektor*, hier z.B. die Werte 4 und -4

```{r, echo = TRUE}
y <- c(4, -4)
y
```

```{r, echo = TRUE}
# x (3 von oben) plus 4 und minus 4, ergibt zwei Werte
x + c(4,-4)

# Gleiches Resultat, weil y vorher als 4 / -4 definiert
x + y
```

-   Sequenzen als Vektoren

```{r, echo = TRUE}
# Vektor mit Zahlen von 1 bis 12
d = seq(from = 1, to = 12) 
d
View(d) # Anzeigen von "d"
str(d) # Struktur von "d"
class(d)
```

-   Mehr Arbeit mit Vektoren

```{r}
# Für jeden Monat (12 Zahlen) einen Wert definieren
rate_pro_monat <- c(0, 100, 200, 50, 0, 0, 0, 0, 100, 0, 0, 0)
rate_pro_monat

# Wert für den zweiten Monat erhalten und getrennt abspeichern
rate_februar <- rate_pro_monat[2]
rate_februar

# Wert für den fünften Monat ergänzen
rate_pro_monat[5] <- 150
rate_pro_monat

# Länge des Vektors herausfinden
length(rate_pro_monat)

# Werte für die Monate Februar-April extrahieren
rate_pro_monat[c(2,3,4)]

# Oder
rate_pro_monat[2:4]
```

-   Vektoren von logischen Werten ("true" oder "false")

```{r}
# Ist jeder Wert von "rate_pro_monat" grösser Null?
rate_pro_monat > 0
```

-   Matrizen

```{r}
# Vektor d in Matrix "m" mit 3 Reihen umwandeln (ergibt Matrix 3 x 4)
m = matrix(data = d, 
           nrow = 3) 

m
View(m) # Anzeigen von "m"
str(m) # Struktur von "m"

# Vektor d in Matrix "n" mit 3 Reihen umwandeln 
# Aber in aufsteigend in Zeilen statt Spalten
# (ergibt Matrix 3 x 4)
n = matrix(data = d, 
           nrow = 3, 
           byrow = TRUE) # Aufteilung nach Zeilen, nicht Spalten

n
View(n) # Anzeigen von "n"
str(n) # Struktur von "n"
```

-   Soll ein *bestehendes Objekt geändert* werden, muss die Änderung immer diesem zugewiesen werden: `bestehendes_objekt <- aenderung(bestehendes_objekt)`
-   Soll ein *neues Objekt erstellt* werden, muss dieses ebenfalls definiert werden: `neues_objekt <- aenderung(bestehendes_objekt)`
-   Je nach Arbeitsablauf macht es Sinn, das bestehende Objekt zu überschreiben oder ein neues zu erstellen...

```{r}
# Erstellt aus der Matrize "n" ein neues Objekt "n_df" als data frame
n_df <- as.data.frame(n)

# Mit "View" sind keine Unterschiede ersichtlich
View(n)
View(n_df)

# Bei der Ausgabe der Objekte sieht man einige Unterschiede
n
n_df

# Offensichtlich wird der Unterschied, wenn man die Struktur der  
# beiden Objekte abgefragt
str(n)
# n ist immer noch eine Reihe von integers
str(n_df)
# n_df ist ein data frame mit Beobachtungen und Variablen

# Überprüfen, ob n und n_df identisch sind
setequal(n, n_df)

# Überschreibt das bestehende Objekt "n" als data frame
n <- as.data.frame(n)

# Nochmals berprüfen, ob n und n_df identisch sind
setequal(n, n_df)
```

-   Benennung von Werten mit `names()`

```{r}
# Ich habe eine Rate pro Quartal
rate_pro_quartal <- c(3.1, 0.1, 5.4, 1.1)
rate_pro_quartal

# Das ist aber nicht so übersichtlich.
# Ich gebe deshalb jedem Wert einen "Namen"
names(rate_pro_quartal) <- c("Q1","Q2","Q3","Q4")
rate_pro_quartal

# Alternative in einem Schritt
rate_pro_quartal_2 <- c("Q1" = 3.1, "Q2" = 0.1, "Q3" = 5.4, "Q4" = 1.1)

# Überprüfen, ob die Objekte identisch sind
rate_pro_quartal == rate_pro_quartal_2
```

## Auswahl von Elementen in einer Tabelle

-   Mit base R: `Objekt[Zeile, Spalte]` -\> z.B. `m[1,3]` ergibt Inhalt der ersten Zeile, dritte Spalte (siehe @tbl-elemente)
    -   Einzelne Zeile/Beobachtung auswählen: `m[2,]` -\> zweite Zeile/Beobachtung, keine Spalte ausgewählt
    -   Einzelne Spalte/Variable auswählen: `m[, 3]` -\> dritte Spalte/Variable, keine Zeile/Beobachtung ausgewählt

| Reihe | Spalte 1 | Spalte 2 | Spalte 3 |
|-------|----------|----------|----------|
| 1     | `[1,1]`  | `[1,2]`  | `[1,3]`  |
| 2     | `[2,1]`  | `[2,2]`  | `[2,3]`  |
| 3     | `[3,1]`  | `[3,2]`  | `[3,3]`  |
| 4     | `[4,1]`  | `[4,2]`  | `[4,3]`  |
| 5     | `[5,1]`  | `[5,2]`  | `[5,3]`  |

: Zugriff auf Elemente nach Reihe und Spalte {#tbl-elemente}

-   Einzelen Spalte/Variable auswählen mit Variablenname, *wenn sie einen Namen hat*: `m[, "Var1"]` -\> Spalte mit Namen "Var1", keine Zeile/Beobachtung ausgewählt
-   Das ist bei grösseren Datensätzen aber eher umständlich. Eine bessere Alternative für Spalten/Variablen, wenn das Objekt ein *data frame* ist (dann sind die Spalten als Variablen benannt): `df$Var1` -\> Spalte/Variable genannt "Var1" wird ausgewählt
-   Je nach benutztem Paket sind andere Schreibweisen möglich, z.B. bei Benutzung von Paketen aus dem "Tidyverse" (siehe @sec-tidyverse)

```{r}
# Beispiel mit den "iris"-Daten
data(iris)

# Auswahl des ersten Wertes der ersten Spalte ("Sepal.Length")
# Diese drei Befehle sind identisch!

iris[1, 1]
iris[1,"Sepal.Length"] # Spalte mit Name "Sepal.Length"
iris$Sepal.Length[1] # Spalte mit Name "Sepal.Length"
```

-   Analog kann mit dem `$` auch auf Elemente von anderen Objekte zugegriffen werden, z.B. auf Elemente eines Outputs einer Operation, die als Listen gespeichert werden:
    -   `fit_iris$coefficients` wird alle Elemente aus dem "Unterelement" `coefficients` des Objekts `fit_iris` (bspw. ein Resultat einer linearen Regression) wiedergeben.
    -   Um die Namen von Elementen von Objekten zu sehen: `names(objekt)`. (Je nach Art des Objektes zeigt es anderes an, bei data frames z.b. einfach die Variablennamen, bei Listen die versch. Elemente etc.)

## Dimensionen und Eigenschaften von Matrizen und data frames

-   Informationen über geladene Daten / Objekte erhalten
-   Hier mit den von R bereitgestellten Daten "iris": Laden mit `data(iris)` (Information zu Schwertlilien)

```{r, echo = TRUE}
data("iris")
View(iris)
str(iris) # Datentypen
```

```{r, echo = TRUE}
dim(iris)
nrow(iris) # Anzahl Fälle / Reihen
ncol(iris) # Anzahl Variablen / Spalten
length(iris) 
# Anzahl Variablen / Spalten 
# (ACHTUNG: in diesem Fall, bei Vektoren gibt es die Länge des Vektors!)
class(iris)
head(iris) # Zeigt erste 6 Beobachtungen
tail(iris) # Zeigt letzte 6 Beobachtungen
summary(iris)
```

## Fehlende Werte

-   `NA` = fehlende Werte
-   `NaN` = "not a number" (bspw. bei Rechnung `0 / 0`)
-   Anzahl `NA` anzeigen für alle Spalten / Variablen: `colSums(is.na())`
-   Anzahl `NA` anzeigen für eine einzelne Spalte: `sum(is.na(df$var))`
-   Logische Überprüfung, ob ein Fall `NA` ist: `is.na()`
-   Fälle mit fehlenden Werten entfernen: `df <- na.omit(df)` (Zuweisung an Objekt nicht vergessen!)
-   Im Gegensatz zu SPSS können in R nicht verschiedene numerische Werte als "missing" codiert werden

```{r}
# Funktioniert nicht, wegen NAs:
mean(car_sales$price)

# Die NAs müssen aktiv ausgeklammert werden von der Analyse:
mean(car_sales$price, na.rm = TRUE)
```

## Kategoriale / ordinale Variablen & labels {#sec-kategoriale-variablen}

-   Auch in R können kategoriale Variablen als Nummer (integers) gespeichert mit einem zugewiesenen "level"
-   R zeigt aber normalerweise nur die "levels" an, nicht die dahinterliegenden integers
-   Labels für numerisch codierte kategoriale Variablen sind in R eher untypisch, häufiger sind die Variablen direkt codiert, als "männlich" oder "weiblich" anstatt "0 = männlich" und "1 = weiblich", d.h. die Variablen werden als Faktorvariablen gespeichert
-   Alternative zu base R: Paket {expss} [@expss]
    -   <https://cran.r-project.org/web/packages/expss/expss.pdf>
    -   Ermöglicht zudem auch SPSS-ähnliche Kreuztabellen, was in R auch eher mühsam ist (siehe @sec-kreuztabellen)
-   Möchte man wirklich Faktorvariablen mit numerischen Werten und Textlabels, geht das z.B. mit folgendem Code: `sex = factor(c(1, 2, 1, 2, 1, 2), labels = c("Female", "Male")))`

```{r}
faktorbeispieldaten <- data.frame(age = c(21, 30, 25, 41, 29, 33), # 6 Altersangaben
                                  sex = factor(c(1, 2, 1, 2, 1, 2), # 6 Geschlechtsangaben
                                               labels = c("Female", "Male")))
# Labels für Geschlecht (1 = "Female", 2 = "Male", automatisch zugeteilt)

# Gleiches Ergebnis, aber ohne numerische Faktorvariable
faktorbeispieldaten_2 <- data.frame(age = c(21, 30, 25, 41, 29, 33), # 6 Altersangaben
                                  sex = factor(c("Female", "Male", "Female", "Male", "Female", "Male"))) 
```

## Variablenlabels

-   Auch Variablenlabels sind in R eher selten, können aber gesetzt werden mit speziellen Paketen, z.B. auch wieder mit {expss} [@expss] mit folgendem Code: `expss::apply_labels(df, var = "label")`

```{r}
faktorbeispieldaten <- expss::apply_labels(faktorbeispieldaten,
                                           age = "Alter in Jahren",
                                           sex = "Geschlecht")
```

::: callout-caution
Wenn Daten in R gelabelt und dann mit {haven} exportiert werden sollen in ein SPSS-Format: Die beiden Pakete können Konflikte erzeugen, siehe hier: <https://cran.r-project.org/web/packages/expss/vignettes/labels-support.html>
:::

# Recodierungen und Berechnung neuer Variablen {#sec-recodierung}

## Recodierung von numerischen Variablen

### Numerische Variablen in numerische Variabeln umcodieren

-   Mit base R: Einfach mit dem "Zuweisungs-Pfeil" (siehe @sec-objekte ) `<-` der Variable neue Werte zuweisen

```{r}
# Bestehende Variable "Petal.Length" logarithmieren
iris$Petal.Length <- log(iris$Petal.Length)

# Neue Variable "sepal_total" erstellen aus Summe
# von Sepal.Length + Sepal.Width
iris$sepal_total <- iris$Sepal.Length + iris$Sepal.Width
```

-   Mit dem Paket {dplyr} aus dem tidyverse (siehe @sec-tidyverse)

```{r}
library(dplyr)
# Bestehende Variable "Petal.Length" logarithmieren
iris <- iris |> 
  dplyr::mutate(PetalLength = log(iris$Petal.Length))

# Neue Variable "petal_total" erstellen aus Summe
# von Petal.Length + Petal.Width
iris <- iris |> 
  dplyr::mutate(petal_total = Petal.Length + Petal.Width)
```

### Numerische Variablen in kategoriale Variabeln (Faktorvariablen) umcodieren

-   Mit der Funktion `cut()` aus Base R

```{r}
iris$petallength_cat <- cut(iris$Petal.Length, # Zuweisen an neue Variable
    c(0, 0.5, 1, 1.5, 2), # Grenzen neuer Kategorien setzen
    labels = c("tief", # Labels der Kategorien definieren
               "tief-mittel",
               "hoch-mittel",
               "hoch"))
```

## Recodierung von kategorialen Faktorvariablen

Mit dem Paket {dplyr} aus dem tidyverse (siehe @sec-tidyverse), weil hier die Vorteile von {dplyr} gegenüber base R definitiv zum Zug kommen!

```{r}
# Ich möchte eine neue Variable "manufact_herkunft" erstellen
# basierend auf der Marke "manufact"
car_sales <- car_sales |> 
  dplyr::mutate(manufact_herkunft = dplyr::case_when(manufact == "Acura"         ~ "USA",
                                                     manufact == "Audi"          ~ "Deutschland",
                                                     manufact == "BMW"           ~ "Deutschland",
                                                     manufact == "Buick"         ~ "USA",
                                                     manufact == "Cadillac"      ~ "USA",
                                                     manufact == "Chevrolet"     ~ "USA",
                                                     manufact == "Chrysler"      ~ "USA",
                                                     manufact == "Dodge"         ~ "USA",
                                                     manufact == "Ford"          ~ "USA",
                                                     manufact == "Honda"         ~ "Asien",
                                                     manufact == "Hyundai"       ~ "Asien",
                                                     manufact == "Infiniti"      ~ "USA",
                                                     manufact == "Jaguar"        ~ "England",
                                                     manufact == "Jeep"          ~ "USA",
                                                     manufact == "Lexus"         ~ "Asien",
                                                     manufact == "Lincoln"       ~ "USA",
                                                     manufact == "Mercedes-Benz" ~ "Deutschland",
                                                     manufact == "Mercury"       ~ "USA",
                                                     manufact == "Mitsubishi"    ~ "Asien",
                                                     manufact == "Nissan"        ~ "Asien",
                                                     manufact == "Oldsmobile"    ~ "USA",
                                                     manufact == "Plymouth"      ~ "USA",
                                                     manufact == "Pontiac"       ~ "USA",
                                                     manufact == "Porsche"       ~ "Deutschland",
                                                     manufact == "Saab"          ~ "Schweden",
                                                     manufact == "Saturn"        ~ "USA",
                                                     manufact == "Subaru"        ~ "Asien",
                                                     manufact == "Toyota"        ~ "Asien",
                                                     manufact == "Volkswagen"    ~ "Deutschland",
                                                     manufact == "Volvo"         ~ "Schweden")
         )

```

## Neue Variablen anhand mehrerer Bedingungen definieren

-   Mit `dplyr::case_when()` lassen sich auch mehrere Bedingungen kombinieren, hier mit numerischen Variablen, nicht mit Textvariabeln wie oben.

```{r}
# Ich möchte eine neue Variable erstellen für die Kombination
# aus Hubraum (engine_s) und Gewicht (curb_wgt)
car_sales <- car_sales |> 
  dplyr::mutate(hubraum_gewicht = dplyr::case_when((engine_s < 3) & (curb_wgt < 3.5) ~ "Klein & leicht",
                                                   (engine_s >= 3) & (curb_wgt < 3.5) ~ "Gross & leicht",
                                                   (engine_s < 3) & (curb_wgt >= 3.5) ~ "Klein & schwer",
                                                   (engine_s >= 3) & (curb_wgt >= 3.5) ~ "Gross und schwer"
                                                   ))
```

# Analysen

## Erste deskriptive Statistiken {#sec-deskriptive-statistiken}

```{r, echo = TRUE}
# Mittelwert von Sepal.Length in iris
# Meine Empfehlung
mean(iris$Sepal.Length)

# Geht auch
mean(iris[, 1])

# Geht auch
mean(iris[, "Sepal.Length"])

# Mittelwert als Objekt abspeichern
sepal_length_mean <- mean(iris$Sepal.Length)
sepal_length_mean

# Ditto Median
sepal_length_median <- median(iris$Sepal.Length)
sepal_length_median

# Einfache Zusammenfassung der Variable
summary(iris$Sepal.Length)
```

-   Alternative z.B. mit dem Paket {vtable}

```{r, echo = TRUE}
#| label: tbl-iris-vtable
#| tbl-cap: Zusammenfassung der Variablen von "iris" (inkl. Klasse)

vtable:::vtable(iris)
```

```{r}
#| label: tbl-iris-sumtable
#| tbl-cap: Zusammenfassende Statistik von "iris"


# Summary statistics
vtable:::sumtable(iris)
```

```{r}
#| label: tbl-iris-sumtable-species
#| tbl-cap: Zusammenfassende Statistik von "iris", getrennt nach "Species"


# Summary statistics, getrennt nach "Species"
vtable:::sumtable(iris,
                  group = 'Species', # summary statistics groupiert nach Variable "Species"
                  group.test = TRUE) # Zeigt statistische Signifikanztests zwischen den Gruppen
```

## Einfache Häufigkeitstabellen

-   Einfache Häufigkeitstabellen sind in R nicht gleich einfach wie in SPSS. Mit base R gibt es z.B. keine Prozente, nur absolute Zahlen.

```{r, echo = TRUE}
# Mit Basisfunktion "table"
table(iris$Species)
```

-   Alternative mit `dplyr::count()` (allgemeine Funktion) oder mit `forcats::fct_count()` (spezifische Funktion für Faktorvariablen):
-   `dplyr::count(iris$Species)` gibt aber einen Fehler, die Funktion muss hinter dem `|>` kommen!

```{r}
iris |> 
  dplyr::count(Species)

forcats::fct_count(iris$Species, 
                   prop = TRUE) # Gibt Verhältnisse an
```

-   Alternative mit `janitor::tabyl()`, ergibt gleichen Output wie oben, lediglich mit leicht anderer Beschriftung.

```{r, warning = FALSE}
janitor::tabyl(iris$Species)

# Alternative, andere Schreibweise, etwas eleganterer Output
iris |> 
  janitor::tabyl(Species)

# Oder mit formatierten Prozentzahlen
iris |> 
  tabyl(Species) |> 
  adorn_pct_formatting(digits = 2)
```

-   Oder mit `expss::fre()` im Stil von SPSS

```{r}
expss::fre(iris$Species)
```

## Kreuztabellen {#sec-kreuztabellen}

-   Einfache Kreuztabellen werden ebenfalls mit der `table()`-Funktion geschrieben (allerdings ohne Randprozente)

```{r}
# Daten laden
data("ToothGrowth")

table(ToothGrowth$supp, ToothGrowth$dose)
```

-   Etwas besser mit der base R-Funktion `xtabs()`, allerdings mit etwas umständlicherem Code

```{r}
xtabs(formula = ~ supp + dose, data = ToothGrowth)
```

-   Oder alternativ ebenfalls mit `janitor::tabyl()` (gleiche Funktion wie bei einer Variable, einfach zweite Variable dazugeschrieben)

```{r}
# Alternative Schreibweise mit tidyverse-Stil
ToothGrowth |> 
  janitor::tabyl(supp, dose)

# Oder eben dann mit allem, was man will
ToothGrowth %>%
  tabyl(supp, dose) %>%
  adorn_totals("col") %>%
  adorn_percentages("row") %>%
  adorn_pct_formatting(digits = 2) %>%
  adorn_ns() %>%
  adorn_title()
```

-   Oder wieder alternativ mit dem Paket {expss} im Stil von SPSS (Achtung, hier mit verschiedenen Funktionen)

```{r}
# Mit absoluten Zahlen
expss::cro(ToothGrowth$supp, list(total(), ToothGrowth$dose), 
           total_statistic = "u_cases")

# Mit Prozenten in Zeile
expss::cro_rpct(ToothGrowth$supp, list(total(), ToothGrowth$dose), 
                total_statistic = "u_cases")

# Mit Prozenten in Spalte
expss::cro_cpct(ToothGrowth$supp, list(total(), ToothGrowth$dose), 
                total_statistic = "u_cases")

# Mit Prozenten für Total
expss::cro_tpct(ToothGrowth$supp, list(total(), ToothGrowth$dose), 
                total_statistic = "u_cases")
```

# Abbildungen

-   Einfache Abbildungen lassen sich mit dem {graphics}-Paket erstellen, welches in base R integriert ist
-   Mehr Individualisierung mit Paket {ggplot2} (@sec-ggplot)

::: callout-tip
## Base R oder ggplot2?

Für einfache, schnelle, explorative Abbildungen die einfachen Abbildungen aus dem {graphics}-Paket nutzen, für schönere, individualiserte (z.B. für Publikationen) eher {ggplot2}.
:::

-   Ausgabe der Abbildungen unten rechts im Fenster "Plots" (evtl. wechseln von "Files")
    -   Abbildung vergrössern in neuem Fenster mit Klick auf "Zoom"
-   Manchmal erkennt R die Daten auch automatisch und macht den richtigen Plot, z.B. macht `plot(iris)` automatisch einen pairs-Plot (weil der ganze Datensatz angegeben wurde; @fig-iris-pairs), `plot(iris$Species)` macht automatisch ein Säulendiagramm der Variable "Species" (@fig-iris-species), weil die Variable "Species" als kategoriale Variable erkannt wird.
-   Möglichkeit, die Abbildungen gleich zu exportieren und in einem Ordner zu speichern (für Benutzung in einer anderen Anwendung)
    -   Manuell (@fig-plot-export-manual)
    -   Bei ggplot2-Abbildungen mit Code: `ggsave(here("Abbildungen", "pairs-plot-iris.png"))` -\> speichert im Unterordner "Abbildungen" des Projektes (@sec-projekte!) die Abbildung im png-Format

![Manuelles Speichern / Exportieren von Abbildungen](images/Screenshot%20(43).png){#fig-plot-export-manual}

## Säulen- / Balkendiagramm

-   Am einfachsten mit `plot()` (siehe auch @sec-abb-plot). Alternativ die Funktion `barplot()`, welche aber speziell ist, weil zuerst eine Häufigkeitstabelle gebildet werden muss (`barplot(table())`).

```{r}
#| label: fig-iris-barplot-species
#| fig-cap: "Säulendiagramm Species"

plot(iris$Species)

#Alternative
# barplot(table(iris$Species))
```

## Histogramm

-   Dazu weitere Beschriftungen mit `xlab` (Label der X-Achse), `ylab` und `main`.
-   Für mehr Übersichtlichkeit Code umbrechen!
-   Weitere Elemente lassen sich ergänzen (`abline(h, ...)` erstellt eine horizontale Linie)

```{r, echo = TRUE}
#| label: fig-iris-hist-sepallength
#| fig-cap: "Histogramm Sepal Length mit Mittelwert (rot)"

hist(iris$Sepal.Length,
     xlab = "Länge in cm",
     ylab = "Häufigkeit",
     main = "Sepal Length")

# Horizontale Linie einfügen
abline(h = mean(iris$Sepal.Length), # Höhe der Linie = Mittelwert 
       col = "red", # Farbe der Linie
       lwd = 1) # Dicke des Striches
```

::: callout-caution
Weil die Funktion `abline()` getrennt von der Abbildung erstellt wird, wird sie einfach immer bei der letzten Grafik eingefügt. Wenn ich zwischen dem Histogramm und der Linie eine andere Abbildung erstellt habe, wird sie einfach dort eingefügt!
:::

## Boxplot

-   Zwei Variablen mit Tilde (\~) trennen

```{r, echo = TRUE}
#| label: fig-iris-boxplot-sepallength
#| fig-cap: "Boxplot Sepal Length"

# Erste Schreibweise, Data nicht explizit zugewiesen
boxplot(iris$Sepal.Length,
        ylab = "Länge in cm",
        main = "Sepal Length")

```

```{r}
#| label: fig-iris-boxplot-sepallength-species
#| fig-cap: "Boxplot Sepal Length nach Species"

boxplot(Sepal.Length ~ Species,
        data = iris, # Andere Schreibweise, Data explizit zugewiesen
        ylab = "Länge in cm",
        xlab = "Species",
        main = "Sepal Length nach Species")
```

## Streudiagramm

-   Metrische Variablen gegeneinander
-   Dritte Variable ("Species") als Farbe
-   Keine Legende standardmässig, muss manuell erstellt werden und ist nicht sehr intuitiv (weil zwei getrennte Objekte erstellt werden ("plot" und "legend"), müssen die Farben manuell aufeinander abgestimmt werden!)

```{r}
#| label: fig-iris-scatter-sepal-petal
#| fig-cap: "Streudiagramm Sepal Length gegen Petal Length"

plot(x = iris$Sepal.Length,
     y = iris$Petal.Length,
     xlab = "Sepal Length",
     ylab = "Petal Length",
     main = "Streudiagramm Sepal Length gegen Petal Length",
     col = iris$Species, # Punkte gefärbt nach Species
     pch = 20) # Schwarze Punkte statt leere Kreise

legend("bottomright", # legende ist unten rechts
       lty = 1, # definiert die Linienart der Legende
       col = c("black", "red", "lightgreen"),
       legend = c("setosa", 
                  "versicolor",
                  "virginica"))
```

-   Reihenfolge und Farbe der Legende muss manuell mit den Kategorien und Farben in der Abbildung abgestimmt werden!
-   Beim genauen Hinsehen stimmen die Farben nicht 1:1 überein!

## Pairs

-   Ersten Überblick gewinnen, nicht zu viele Variablen gleichzeitig!
-   Wenig sinnvoll bei nicht-metrische Variablen (siehe "Species")

```{r, echo = TRUE}
#| label: fig-iris-pairs-all
#| fig-cap: "Pairs-plot aller Variablen in iris"

# Alle Variablen von iris
pairs(iris)
```

-   Kategoriale Variable "Species" mach hier weniger Sinn, zudem wird der Plot zu gross bei zu vielen Variablen -\> Variablen einschränken für Plot

```{r}
#| label: fig-iris-pairs-numerical
#| fig-cap: "Pairs-plot der numerischen Variablen in iris"

# Befehl eingeschränkt auf Spalten 1:4 von iris 
# (und alle Zeilen, keine Eingabe vor Komma)
pairs(iris[,1:4])
```

## Standard-Plot (inkl. Streudiagramm) {#sec-abb-plot}

-   Die Standardfunktion `plot()` erkennt je nachdem auch automatisch, wie die Zieldaten aussehen und erstellt selständig eine passende Abbildung dazu
    -   `plot(df)` -\> alle Variablen des Datensatzes, ergibt einen pairs-Plot (@fig-iris-pairs)
    -   `plot(df$Var1)` -\> Variable 1 des Datensatzes, ergibt z.B. bei kategorialen Variablen ein Säulendiagramm (@fig-iris-species)
    -   `plot(df$Var1, df$Var2)` -\> Variable 1 und Variable 2 des Datensatzes zusammen, ergibt bei numerischen Variablen einen Scatterplot (@fig-iris-sepalwidth-sepallength)

```{r}
#| label: fig-iris-pairs
#| fig-cap: "Pairs-Plot aller Variablen in iris"

plot(iris)
```

```{r}
#| label: fig-iris-species
#| fig-cap: "Säulendiagramm 'Species'"

plot(iris$Species)
```

```{r}
#| label: fig-iris-sepalwidth-sepallength
#| fig-cap: "Streudiagramm Sepal Width - Sepal Length"

plot(iris$Sepal.Width, iris$Sepal.Length)
```

## ggplot2 {#sec-ggplot}

-   Paket zur Datenvisualisierung, Teil des "Tidyverse"-Universum (siehe unten @sec-tidyverse)
-   Gleiche Syntaxlogik wie andere "Tidyverse"-Pakete
-   Grundsätzliche Idee: Abbildung erstellen in Ebenen "von unten nach oben"
    -   Zuunterst: Daten
    -   Nächste Ebene: Was soll wo hin (X- und Y-Achse, ggf. Füllung und Farbe; "aesthetics")
    -   Nächste Ebene: Als was visualisieren (Säulen, Boxplot, Punkte etc.)
    -   Nächste Ebene: Beschriftungen
    -   Nächste Ebene...
-   Einfachster Code: `ggplot(df, aes(x = Var1, y = Var2)) + geom_function()`\
-   Literatur hier:
    -   @wickham2016a (online hier: <https://ggplot2-book.org/index.html>)
    -   @chang\
-   **Viele** Einstellungsmöglichkeiten bei Abbildungen, siehe z.B. @fig-iris-sepallength-histogram-ggplot (Histogramm mit Standardeinstellungen), @fig-iris-sepallength-histogram-ggplot-facet (Histogramm mit "faceting", Aufteilung der Abbildung in bestehende Kategorien), @fig-iris-sepallength-histogram-ggplot-identity (Histogramm mit Füllung je nach Kategorie) oder @fig-iris-sepal-scatterplot (Streudiagramm mit Regressionsgeraden, aufgeteilt nach Kategorie).

```{r, echo = TRUE}
#| label: fig-iris-sepallength-histogram-base
#| fig-cap: "Histogramm Sepal Length mit base R"
#| include: FALSE

hist(iris$Sepal.Length,
     xlab = "Länge in cm",
     ylab = "Häufigkeit",
     main = "Sepal Length (mit Base R)")
```

```{r}
#| label: fig-iris-sepallength-histogram-ggplot
#| fig-cap: "Histogramm Sepal Length mit ggplot2"

# Variante 1 mit ggplot2
ggplot(iris) +                                     # Daten 
    aes(x = Sepal.Length) +                        # Aesthetics 
    geom_histogram() +                             # Art der Visualisierung 
    labs(                                          # Labels 
        x = "Länge in cm",                         # X-Achse
        y = "Häufigkeit")                          # Titel
```

```{r}
#| label: fig-iris-sepallength-histogram-ggplot-facet
#| fig-cap: "Histogramm Sepal Length mit ggplot2, aufgeteilt nach Species"

# Variante 2 mit ggplot2
ggplot(iris) +
    aes(x = Sepal.Length) +
    geom_histogram(binwidth = 0.2) +   # Breite der bins definiert anstatt default
    facet_wrap(~ Species) +            # Pro Ausprägung von "Species" eine Abbildung  
    labs(x = "Länge in cm",
        y = "Häufigkeit")
```

```{r}
#| label: fig-iris-sepallength-histogram-ggplot-identity
#| fig-cap: "Histogramm Sepal Length mit ggplot2, Species überlagernd"

# Variante 3 mit ggplot2
ggplot(iris) +
    aes(x = Sepal.Length,                   # X-Achse
        fill = Species) +                   # Füllung der bins
    geom_histogram(binwidth = 0.2,          # Breite der bins definiert anstatt default
                   alpha = 0.5,             # Durchsichtigkeit der Säulen
                   position = "identity") + # Überlagerung der Säulen
    theme_minimal() +                       # Weisser Hintergrund, kein Rahmen
    labs(x = "Länge in cm",
        y = "Häufigkeit")
```

```{r}
#| label: fig-iris-sepal-scatterplot
#| fig-cap: "Scatterplot Sepal Length x Sepal Width mit ggplot2, inkl. Regressionsgeraden"

ggplot(iris) +
  aes(x = Sepal.Length, 
      y = Sepal.Width,
      color = Species,
      fill = Species) +
  geom_point() +
  geom_smooth(method = "lm") +
  theme_minimal() +
  labs(x = "Sepal Width in cm",
       y = "Sepal Length in cm")
```

-   Man kann es auch übertreiben mit den Einstellungen (@fig-iris-species-barplot)...

```{r}
#| label: fig-iris-species-barplot
#| fig-cap: "Säulendiagramm Species mit VIELEN Individualisierungen..."


ggplot(iris) +
  aes(x = Species) +
  geom_bar(fill = "pink") + # Pinke Füllung
  stat_count(geom = "text", # Datenbeschriftung
             colour = "yellow", # Farbe der Datenbeschriftung
             size = 7.5,        # Grösse der Datenbeschriftung
             angle = -45,       # Beschriftung gekippt um -45 Grad
             aes(label = after_stat(count)), # Label ist die gezählte Anzahl
             position = position_stack(vjust = 0.5)) + 
  # Beschriftung ist vertikal nach unten versetzt
  theme_dark()              # Anderes "theme"
```

-   @fig-iris-scatter:
    -   Füllfarbe der Punkte in der ZHAW-Farbe im HEX-Code (`#0079DB`), Punkte vergrössert (für die Umwandlung eines CMYK in Hex, z.B.: <https://colordesigner.io/convert/cmyktohex>)
    -   Grenzen der X-Achse manuell gesetzt mit `xlim()` und `ylim()`
    -   Beschriftungstext in Abbildung drin mit `annotate()`
    -   Pfeil mit `geom_curve()`

```{r}
#| label: fig-iris-scatter
#| fig-cap: "Verteilung von Petal.Length und Sepal.Length (iris) in den ZHAW-Farben, mit weiteren Zusätzen"

ggplot(iris) +
  aes(x = Petal.Length,
      y = Sepal.Length) +
  geom_point(col = "#0079DB",
             size = 3) +
  xlim(0, 2.2) +
  ylim(3, 8.3) +
  annotate("text",
           x = 1,
           y = 7.5,
           label = "Diese Gruppe hat grössere Blumen") +
  geom_curve(aes(x = 1,
                 y = 7.2,
                 xend = 1.4,
                 yend = 6.5),
             arrow = arrow()) +
  theme_minimal() +
  labs(x = "Länge Blüttenblatt [in cm]",
       y = "Länge Kelchblatt [in cm]")
```

-   Für Zusatzpakete zu ggplot2 und Inspiration, wie man was sonst noch visualisieren kann: <https://exts.ggplot2.tidyverse.org/gallery/>

## Abbildungen über das Menu erstellen mit dem {esquisse}-Paket {#sec-esquisse}

-   Interaktive Erweiterung für RStudio für die Erstellung von Abbildungen
-   Speziell daran: Dieses Paket wird einmal installiert (`install.packages("esquisse")`), muss aber nachher nicht mit `library()` geladen werden (s. @sec-pakete), sondern steht als "Addin" in RStudio zur Verfügung (@fig-addin-esquisse; auswählen über "'ggplot2' builder")

![Zugriff auf "esquisse" über die Addins](images/Screenshot%20(50).png){#fig-addin-esquisse}

-   Ablauf:
    1.  Datensatz auswählen mit "Select a data.frame" (Daten müssen als data frame vorhanden sein!, @fig-esquisse-datenauswahl)
    2.  Variablen ziehen, wohin man sie will: Nur eine Variable: X-Achse, mehrere Variablen: Y-Achse dazu, ggf. Grösse oder Farbe der Punkte, bei kategoriellen Variablen ist auch eine Gruppierung oder "facets" möglich (@fig-esquisse-einstellungen)
    3.  Ggf. die Art der Abbildung ändern, wenn einem der Vorschlag nicht gefällt
    4.  Ggf. unten noch die Einstellungen ändern zu Beschriftung, Farbe etc.
    5.  Unten rechts auf "Code" -\> "Copy to Clipboard" und den Code kopieren (oder direkt einfügen lassen mit "Insert Code in Script", @fig-esquisse-codeexport)
    6.  Ggf. am Code selbst noch Änderungen vornehmen
    7.  Resultat bestaunen (@fig-usarrests-all)

![Auswahl der Daten im {esquisse}-Addin](images/Screenshot%20(53).png){#fig-esquisse-datenauswahl}

![Einstellungen für die Abbildung im {esquisse}-Addin](images/Screenshot%20(56).png){#fig-esquisse-einstellungen}

![Code-Export aus dem {esquisse}-Addin](images/Screenshot%20(57).png){#fig-esquisse-codeexport}

```{r}
#| label: fig-usarrests-all
#| fig-cap: "Streudiagramm von USArrests mit vier Variablen"


ggplot(USArrests) +
  aes(x = Murder, 
      y = Assault, 
      colour = Rape, 
      size = UrbanPop) +
  geom_point(shape = "circle") +
  scale_color_viridis_c(option = "inferno") +
  theme_minimal()
```

# Resultate von Analysen als Objekte

-   Objekte in R müssen nicht zwingend Zahlen oder Datensätze sein. Als Objekte können auch gespeichert werden:
    -   Resultate von Analysen
    -   Zeitreihen
    -   Listen
    -   etc.
-   Ergebnisse von Regressionen werden bspw. als "Listen" gespeichert

```{r}
data(iris)

# Einfache lineare Regression
fit_iris <- lm(Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width, 
               data = iris)

# Zusammenfassung des Modells
summary(fit_iris)
```

-   Auf einzelne Objekte der Resultate kann wiederum zugegriffen werden mit dem `$`

```{r}
# Elemente der Liste anschauen
names(fit_iris)

# Koeffizienten anschauen
fit_iris$coefficients
```

-   Einzelne Elemente der Resultate können geplottet werden, mit `plot(fit_iris)` können sechs Plots erzeugt

```{r}
#| label: fig-lm-iris-resid-fit
#| fig-cap: "Residuals vs. Fitted Plot von lm(iris)"

plot(fit_iris, which = 1)
```

```{r}
#| label: fig-lm-iris-normalplot
#| fig-cap: "Normalplot von lm(iris)"
#| 
plot(fit_iris, which = 2)
```

```{r}
#| label: fig-lm-iris-scale-location
#| fig-cap: "Scale Location Plot von lm(iris)"

plot(fit_iris, which = 3)
```

```{r}
#| label: fig-lm-iris-scale-leverage-plot
#| fig-cap: "Cook's Distance Plot von lm(iris)"

plot(fit_iris, which = 4)
```

```{r}
#| label: fig-lm-iris-scale-base-leverage-plot
#| fig-cap: "Residuals vs. Leverage Plot von lm(iris)"

plot(fit_iris, which = 5)
```

```{r}
#| label: fig-lm-iris
#| fig-cap: "Cooks Distance vs. Leverage Plot von lm(iris)"

plot(fit_iris, which = 6)
```

# Wo finde ich Hilfe?

-   Google
-   R-Hilfe: In der Konsole mit Fragezeichen den Begriff eingeben, z.B. `?median` (@fig-help-median), `?boxplot` (@fig-help-boxplot) oder `?filter` (@fig-help-filter).

![Hilfe zu median (Paket {stats})](images/Screenshot%20(64).png){#fig-help-median}

![Hilfe zu boxplot (Paket {graphics})](images/Screenshot%20(65).png){#fig-help-boxplot}

![Hilfe zu filter (Funktion existiert in drei Paketen; davon das gewünschte Auswählen)](images/Screenshot%20(63).png){#fig-help-filter}

-   Online-Klassen, Unterlagen, Lernmodule, Beispielcodes etc.: <https://stats.oarc.ucla.edu/r/>

-   Die Tidyverse-Bibel: <https://r4ds.hadley.nz/> (siehe @sec-tidyverse)

-   "Learning Statistics with R", auf <https://learningstatisticswithr.com/lsr-0.6.pdf>, ein Manuskript für Psychologiestudierende von @navarro. Gut für die basics, ohne Verweise auf das Tidyverse (alles in base R)

-   "R Workbook: Are you ready for R?", auf <https://www.michaelstrausz.com/r-workbook>, ein einfaches online-Lehrbuch von @strausza. Auch mit Hinweisen auf das Tidyverse.

-   Verschiedene (technische) Handbücher zu R: <https://rstudio.github.io/r-manuals/>

-   ChatGPT: Es gib mittlerweile einige Pakete zu ChatGPT, welche beim Codieren helfen sollen, indem sie Code-Vorschläge machen oder Code auf Fehler überprüfen.

    -   Man braucht auf jeden Fall einen API key (bekommt man einfach über den Zugang zu ChatGPT), welcher in RStudio hinterlegt werden muss

    -   {chatgpt}: @chatgpt-4; <https://github.com/jcrodriguez1989/chatgpt>

    -   {gptstudio}: (noch nicht auf CRAN); <https://michelnivard.github.io/gptstudio/>

::: callout-warning
Wie häufig bei ChatGPT stimmt nicht immer alles, was die AI sagt, auch wenn es plausibel tönt! Manchmal erfindet sie auch nicht existierende Funktionen...
:::

# Weiterführendes

## R-Skript vs. Markdown / Quarto

-   Skripte für reine Analysen, Text muss (analog zu SPSS-Syntax) auskommentiert werden mit `#`
-   Skripte strukturieren mit vier Trennstrichen `----` am Ende des Titels
    -   Kapitelstruktur ein-/ausschalten im Fenster oben rechts mit "Outline"
-   Markdown / Quarto: Primär Text-Dokumente, Code muss eingefügt werden in sogenannten "Chunks" (in Quarto sind auch Chunks für Python und andere Sprachen möglich!)
-   Analysen können auch inline im Text eingebaut werden, z.B. ergibt die Eingabe des Codes `"r (mean(iris$Sepal.Width)) + (median(ToothGrowth$len))"` im Text direkt das Resultat dieser Berechnung (`r (mean(iris$Sepal.Width)) + (median(ToothGrowth$len))`) im Text wieder. D.h. Berechnungen lassen dich direkt in den Text eines Berichts einbauen; wenn sich die Daten verändern, kann der Bericht automatisiert neu erstellt werden und die neu gültigen Zahlen werden automatisch angepasst im Bericht
-   Das gleiche gilt für im Bericht eingebaute Abbildungen, diese müssen nicht angepasst werden bei veränderten Daten
-   Falls umfangreicher Code besteht, ist dieser sinnvoller in einem separaten R-Skript. Auf dieses kann verwiesen werden mit `source("skript.R")`
-   Erstellen von Publikationen direkt in RStudio (zum Beispiel dieses Dokument)
-   Betrieben von Posit, die auch RStudio betreiben -\> Open Source
-   <https://quarto.org/>
-   Kann auch in anderen Programmen betrieben werden (z.B. VS Code)
-   Gute Einbettung von Zotero!
-   Output in div. Formaten möglich (Word, PDF, Folien, HTML)
-   Kein Copy/Paste von SPSS zu Excel zu Word!
-   Hat visuellen Editor (@fig-quarto-visual-editor)!

![Quarto: Visueller Editor](images/Screenshot%20(67).png){#fig-quarto-visual-editor}

-   Python funktioniert ähnlich, aber anders als R, siehe folgender Chunk (aber die Ausgabe in diesem Dokument scheint leicht anderer Logik zu folgen als bei einem R-Chunk)
-   Code unten in Python

```{python}
# Statistikpaket für python laden
import statistics

# Daten definieren
data1 = [1, 3, 4, 5, 7, 9, 2]

# Mittelwert ausrechnen
statistics.mean(data1)

# Auch mit python können in RStudio Objekte definiert werden
x = statistics.mean(data1)

# x ausgeben
x

# Printen mit Text
print("Mean is:", x)
```

## Tidyverse {#sec-tidyverse}

-   Meist verbreitetes Paket für Datenaufbereitung, -analyse und -visualisierung
-   Eigene Syntaxstruktur[^2], aufbauend / hintereinander verknüpft, weniger verschachtelt als base R:
    1.  Welche Daten sollen benutzt werden?
    2.  Was soll damit gemacht werden?
    3.  Jeweils verketten mit dem "Pipe"-Operator (`|>`, früher `%>%`); bedeutet sozusagen "dann mach das..."
-   Codebeispiel für base R und tidyverse: Im iris-Datensatz die Species "virginica" filtern und daraus eine neue Variable bilden mit der Summe aus "Sepal Length" und "Sepal Width", diese Daten neu abspeichern

[^2]: Es gibt durchaus Stimmen, die sich gegenüber Tidyverse kritisch äussern mit dem Argument, es sei unnötig, mache alles komplizierter, und mit Base R sei auch alles bereits möglich, was das Tidyverse kann.

```{r}
# Ganzes Tidyverse laden
library(tidyverse)
# Daten laden
data("iris")

# Mit base R
virginica_base <- transform(subset(iris, Species == "virginica"),
                            sepallength_width = (Sepal.Length + Sepal.Width),
                            petallength_width = (Petal.Length + Petal.Width))

View(virginica_base)

# Mit tidyverse
virginica_tidy <- iris |> 
  dplyr::filter(Species == "virginica") |> 
  dplyr::mutate(sepallength_width = (Sepal.Length + Sepal.Width)) |>   
  dplyr::mutate(petallength_width = (Petal.Length + Petal.Width))

View(virginica_tidy)

# Randnotiz: Tidyverse beginnt die Zeilennummerierung wieder bei 1, mit base R 
# bleibt die Zeilennummerierung wie im ursprünglichen Datensatz, fängt bei 101 an
```

-   Das tidyverse ist das ganze "Universum", zusammengesetzt aus verschiedenen Paketen.

-   Die wichtigsten Pakete sind:

    -   {ggplot2}: @ggplot2-4, Daten visualisieren

    -   {tidyr}: @tidyr, Daten bereinigen / Umformatieren

    -   {dplyr}: @dplyr, Datenmanipulation

    -   {readr}: @readr, Daten einlesen in verschiedenen Formaten

    -   {stringr}: @stringr, Umgang mit string-Variablen

    -   {forcats}: @forcats, Umgang mit kategoriellen Variablen (Faktorvariablen)

    -   {lubridate}: @lubridate, für den Umgang mit Kalenderdaten und Zeiten

    -   Und weitere, siehe <https://www.tidyverse.org/packages/>

-   Open source Lehrbuch zum Tidyverse: [@wickham2016b] (Hadley Wickham ist Chief Scientist bei Posit, der Firma, die RStudio betreibt)

-   Nette Ergänzung, wenn Funktionen aus {tidyr} oder {dplyr} genutzt werden: {tidylog} ist ein sogenannter "wrapper" für Funktionen aus diesen beiden Paketen: Resultat ist das gleiche, aber es wird jeweils angezeigt, was sich nach jedem Arbeitsschritt verändert hat [@tidylog]. Nutzung: `tidylog::filter()` anstatt `dplyr::filter()` etc.

```{r}
#| echo: TRUE
#| warning: TRUE


# Mit tidylog
virginica_tidylog <- iris |> 
  tidylog::filter(Species == "virginica") |> 
  tidylog::mutate(sepallength_width = (Sepal.Length + Sepal.Width)) |>   
  tidylog::mutate(petallength_width = (Petal.Length + Petal.Width))
```

-   Beachte: Trotz 50 Fällen, die bleiben, gibt es nur 29 eindeutige (unique) Fälle, weil einige Fälle mehrfach vorkommen (siehe `table(iris$sepallength_width`))

## Arbeit mit Textvariablen (character / string)

-   Nochmals ein Thema für sich...
-   Im base R gibt es diverse Funktionen dazu, aus dem Tidyverse gibt es das {stringr}-Paket [@stringr]

## Loops (`while` und `for`)

-   Ein loop ist ein Stück Code, z.B. eine Reihe von Befehlen, die wiederholt werden, bis ein Kriterium zum Abschluss erfüllt ist
-   Beispiele unten aus @navarro, Kap. 8.2
-   Gängigste Arten von loops:
    -   `while`: Solange die `while`-Bedingung erfüllt ist (mit `TRUE` im Hintergrund), läuft der Befehl weiter
    -   `for`: Für jedes Element eines Vektors wird ein Befehl ausgeführt

```{r}
# Beispiel für einen while-loop:
# Anfangen mit x = 0
x <- 0

while (x < 1000) { # Solange x kleiner 1000 ist
  x <- x + 17      # wird x immer um 17 erhöht
  }

print(x)
# Der loop hat aufgehört bei 1003 nach 59 Wiederholungen
# (59 x 17 = 1003)
```

```{r}
# Beispiel für einen for-loop:
for (i in 1:3) {  # Für jedes Element des Vektors 1:3
  print("hello")  # Gib "hello" aus
  }
```

## Bedingungen (`if`)

-   Auch eine Bedingung für das Ausführen eines Codes, aber nur einmalig, je nachdem ob eine Bedingung erfüllt ist oder nicht (bei loops gibt es eine bestimmte Anzahl wiederholungen)
-   Beispiele unten aus @navarro, Kap. 8.3

```{r}
# Elemente festlegen
today <- Sys.Date() # heutiges Datum bestimmen
day <- weekdays(today) # Wochentag heute bestimmen

# Ausgabe je nach Tag
if(day == "Monday") {
  print("I don’t like Mondays")
  } else {
print("I’m a happy little automaton")
    }
```

## Funktionen (`function`)

-   Häufig werden bereits bestehende Funktionen aus R benutzt (z.B. `mean()`, `round()` etc.), man kann aber auch eigene Funktionen schreiben
-   Beispiele unten aus @navarro, Kap. 8.4
-   Funktionen werden als Objekte gespeichert in der Umgebung ("Environment")

```{r}
# Erstelle eine Funktion "vierfach"
vierfach <- function(x) {
  y <- x * 4        # Multipliziere die Eingabe x mit 4 und speichere es als y
  return(y)         # Gib das Resultat y aus
}

# Ausführen der Funktion
vierfach(10)

# Zweites Beispiel mit Eingabe zweier Werte
summiere <- function(a, b) {
  c <- a + b
  return(c)
}

# Ausführen der Funktion
summiere(2, 3)
```

## Git und github {#sec-github}

-   System zur Kollaboration an Code und Versionsontrolle
-   Aus Software Center "Git" installieren
-   Ist in RStudio integriert (oben rechts "Git"), braucht kein weiteres Programm
-   <https://github.com> resp. eigene Version für ZHAW: <https://github.zhaw.ch/>
-   Unter <https://github.com/orlzen/intro-to-R> ist z.B. der Code für diese Einführung öffentlich sichtbar, die Änderungen sind protokolliert und können von allen nachvollzogen werden.
-   Einführung speziell für R z.B. hier: <https://happygitwithr.com/index.html>
-   Im Intranet der ZHAW: <https://zhaw.sharepoint.com/:b:/r/sites/osc/Freigegebene%20Dokumente/2021_10_27%20-%20Git%20why%20and%20how.pdf?csf=1&web=1&e=2EehhW> oder <https://intra.zhaw.ch/departemente/school-of-engineering/services/dienste-tools/soe-it-infrastruktur/git-umgebung/>

## Shiny {#sec-shiny}

-   App zur Datenvisualisierung, -simulation etc.
-   Kann in RStudio ausgeführt werden, aber auch in Homepages eingebaut werden
-   Infos hier: <https://shiny.rstudio.com/tutorial/> und hier [@wickham2021] (<https://mastering-shiny.org/>)
-   Siehe `app.R` -\> Öffnen in RStudio -\> Oben rechts auf "Run App" klicken
-   Z.B. auch im Einsatz beim statistischen Amt der Stadt Zürich: <https://statzuerich.shinyapps.io/kali/>

# Literatur

::: {#refs}
:::

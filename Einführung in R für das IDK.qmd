---
title: "Einführung in R für IDK"
author: "Lorenz Biberstein, IDK, ZHAW"
date: "`r Sys.time()`"
date-format: medium
format:
  html:
    embed-resources: true
always_allow_html: true
toc: true
toc-depth: 5
toc-title: "Inhalt"
toc-location: left
number-sections: true
number-depth: 3
lang: "de-DE"
---

# Einleitung

## To do

-   Deskriptive Analysen, alltägliche Anwendungen für uns
-   Mehr Grundsätzliches am Anfang, weniger Fortgeschrittenes
-   Alle benutzten Codes aus den Chunks in R Skript übertragen

```{r}
#| echo: false
#| warning: false
library(here) # Für saubere Pfade
library(readr) # Import von Daten in versch. Formaten
library(readxl) # Import von Excel
library(ggplot2) # Schöne Abbildungen
library(vtable) # Beschreibung von Daten
library(janitor) # Für schöne Tabellen
library(haven) # Import von SPSS, Stata etc.
```

```{r setting}
#| echo: false
#| warning: false
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE
)
```

## Vorbereitung

Dies ist eine kurze Einleitung in R und RStudio für das IDK. Dazu gehören die folgenden Dateien:

-   Einführung in R für das IDK.R (Beispielcodes)
-   Datensätze in verschiedenen Formaten:
    -   Alpenquerender_Gueterverkehr_Schiene.xlsx
    -   Arrivals.txt
    -   car_sales.sav
    -   Churn.csv
    -   Treibstoffpreise_CH.rda
-   app.R (shiny-Demo)

## R und RStudio

-   Basisprogramm ist R
-   Benutzt wird es aber meistens über RStudio (angenehmere Oberfläche)
-   Installieren aus Software Center: Zuerst R (muss später nie mehr geöffnet werden), dann RStudio (@fig-rstudio-softwarecenter)

![R und RStudio im Software Center](images/Screenshot.png){#fig-rstudio-softwarecenter}

![Layout RStudio](images/image-267797392.png){#fig-layout-rstudio}

-   RStudio ist unterteilt in verschiedene Fenster (die sich unterschiedlich anordnen lassen, siehe @fig-layout-rstudio; Farbe und Schrift lassen sich anpassen!)
-   Am wichtigsten:
    -   Skript (hier oben links)
    -   Konsole für freie Eingabe von Code und Output von Analysen (unten links)
    -   Geladene Daten & Objekte ("Environment"; oben rechts)
    -   Projektordner ("Files"; unten rechts)
    -   Abbildungen ("Plots"; unten rechts)

## Kleinere Unterschied zu SPSS

-   Skripte (analog zu SPSS-Syntax) und Konsole (für freie Eingabe)
-   Praktisch keine Menuführung für Analysen (Ausnahme: Erweiterung für Abbildungen)
-   R ist case sensitive! "x" ist nicht das gleiche wie "X"!
-   Nicht wie in SPSS versch. Fenster für Syntax, Output und Daten, sondern alles in einem Fenster (Ausnahmen sind möglich, z.B. zusätzliches Fenster für Abbildungen)

## Projekte {#sec-projekte}

-   Sehr zu empfehlen, sobald man nicht nur eine einzelne quick and dirty-Analyse machen will: Projekt anlegen
    -   File -\> New Project -\> (@fig-new-project)
        -   Auswahl aus verschiedenen Ablagemöglichkeiten. Am einfachsten: "New Directory".
        -   Falls mit Versionskontrolle gearbeitet wird (siehe @sec-github): "Version Control"

![Neues Projekt eröffnen](images/Screenshot%20(39).png){#fig-new-project}

-   Vorteile:
    -   Ein Hauptordner für ganzes Projekt
    -   R kann Einstellung pro Projekt speichern
    -   R weiss, welche Skripte, Dateien etc. zu welchem Projekt gehören
    -   In RStudio von Projekt zu Projekt wechseln, vereinfacht Organisation
-   Getrennte Unterordner für Daten, Analysen, Abbildungen, Bericht etc.
-   Pfade à la "`C:\Users\bibs\OneDrive - ZHAW\R\Einführung in R für das IDK`" sind verpönt, weil nicht anwendbar auf anderen Geräte / für andere Benutzer
-   Allgemein gültige Pfade mit dem Projekt `here: library(here)`
    -   "`here() starts at C:/Users/bibs/OneDrive - ZHAW/R/Einführung in R für das IDK`"
    -   Daten einlesen mit `Churn <- read_table(here("Daten", "Churn.csv"))` funktioniert für alle Personen, solange sie in ihrem Hauptprojektordner einen Unterordner "Daten" haben, in dem die Daten "Churn.csv" abgelegt sind

## Base R vs. Pakete ("libraries")

-   Basisinstallation ist "Base R" ({base}); kommt bereits mit sehr vielen Anwendungen
-   Weitere bereits installierte Pakete:
    -   {stats} für statistische Anwendungen
    -   {graphics} für einfache Abbildungen
-   Verschiedene mehr oder weniger spezielle Anwendungen benötigen aber spezielle Pakete
-   Paket installieren (nur beim ersten Mal): `install.packages("ggplot2")`
-   Paket laden für Nutzung: `library(ggplot2)` (Keine Anführungszeichen nötig)
-   Achtung, wenn verschiedene Pakete *Funktionen mit gleichem Namen* verwenden (@fig-conflicting-functions)
-   Dann muss ggf. das Paket mit zwei Doppelpunkten vorangestellt werden (R zeigt beim laden der beiden fraglichen Pakete an, welche Funktion aus welchem Paket benutzt wird):
    -   `dplyr::filter()`
    -   `stats::filter()`

![Konflikte bei der Funktion "filter()", die im Paket {dplyr} und im Paket {stats} vorkommt, ebenso "lag()"](images/Screenshot%20(44).png){#fig-conflicting-functions}

-   Unterschied zu SPSS: Dort gibt es keine verschiedenen Pakete, alle Funktionen sind für SPSS klar und eindeutig...
-   Einige Funktionen kommen auch identisch in versch. Paketen vor!

# Daten in R

-   R kann verschiedene Daten *gleichzeitig laden* (oben rechts in "Environment"; @fig-environment-list und @fig-environment-grid, je nach Darstellung), diese können *verschiedene Typen* sein:
    -   Klassische Datensätze mit Fällen in Zeilen und Variablen in Spalten (meistens "data frame" oder "tibble" genannt in RStudio, hier z.B. "alpenquer", "Arrivals", "car_sales", "Churn")
    -   Matrizen (z.B. "m")
    -   Vektoren (z.B. "y")
    -   Nur ein einzelner Wert (z.B. "sepal_length_mean" oder "x")
    -   Liste von Werten, die im Gegensatz zu Vektoren genauer spezifiziert sind (z.B. Resultate von Analysen mit Koeffizienten, Parameter etc., z.B. "fit-iris")

![Environment mit verschiedenen geladenen Objekten; Ansicht "List"](images/Screenshot%20(40).png){#fig-environment-list}

![Environment mit verschiedenen geladenen Objekten; Ansicht "Grid"](images/Screenshot%20(42).png){#fig-environment-grid}

-   Befehle müssen die zu benutzenden Daten eindeutig identifizieren
    -   Z.B. `mean(iris$Sepal.Width)` berechnet den Mittelwert der Variable "Sepal.Width" im Datensatz "iris", `median(ToothGrowth$len)` berechnet den Median der Variable "len" im Datensatz "ToothGrowth" etc.
-   Daten können auch angeschaut werden, entweder mit `View()` oder durch klicken auf das Objekt im Fenster "Environment"
-   In einer Analyse können Daten aus verschiedenen Datensätzen kombiniert werden, z.B. `(mean(iris$Sepal.Width)) + (median(ToothGrowth$len))`

# Arbeiten in R

-   Code ausführen:
    -   Code markieren oder ganze Zeile auswählen
    -   Ausführen entweder mit *Ctrl + Enter*
    -   Oder in Konsole individuell mit *Enter*
    -   Oder oben rechts auf "Run"
-   Tipp: Teil eines längeren Codes markieren und mit *Ctrl + Enter* ausführen, bspw. ergibt `round(sqrt(122))` 11, ich kann aber auch nur `sqrt(122)` markieren und mit *Ctrl + Enter* ausführen, dann erhalte ich die ungerundete Zahl

## Einfache Eingabe und Zuweisung an *Objekte* {#sec-objekte}

-   Normale Eingabe von Code in Konsole

```{r, echo = TRUE}
1 + 2
```

-   Zuweisung des Werts an Objekt "x" mit Pfeil

```{r, echo = TRUE}
x <- 1 + 2
x
```

-   Benutzung des Objekts "x"

```{r, echo = TRUE}
x + 4
```

-   Eingabe mehrere Werte als Vektor, hier z.B. die Werte 4 und -4

```{r, echo = TRUE}
y <- c(4, -4)
y
```

-   Komplizierteres

```{r, echo = TRUE}
# x (3) plus 4 und minus 4, ergibt zwei Werte
x + c(4,-4)

# Gleiches Resultat, weil y vorher als 4 / -4 definiert
x + y
```

## Datenformate

-   R kann Informationen in verschiedenen Formaten speichern

```{r, echo = TRUE}
# Vektor mit Zahlen von 1 bis 12
d = seq(from = 1, to = 12) 
d
View(d) # Anzeigen von "d"
str(d) # Struktur von "d"

# Vektor d in Matrix "m" mit 3 Reihen umwandeln (ergibt Matrix 3 x 4)
m = matrix(data = d, 
           nrow = 3) 

m
View(m) # Anzeigen von "m"
str(m) # Struktur von "m"

# Vektor d in Matrix "n" mit 3 Reihen umwandeln 
# Aber in aufsteigend in Zeilen statt Spalten
# (ergibt Matrix 3 x 4)
n = matrix(data = d, 
           nrow = 3, 
           byrow = TRUE) # Aufteilung nach Zeilen, nicht Spalten

n
View(n) # Anzeigen von "n"
str(n) # Struktur von "n"
```

## Auswahl von Elementen in einer Tabelle

-   Mit base R: `Objekt[Zeile, Spalte]` -\> z.B. `m[1,3]` ergibt Inhalt der ersten Zeile, dritte Spalte
-   Einzelne Zeile/Beobachtung auswählen: `m[2,]` -\> zweite Zeile/Beobachtung, keine Spalte ausgewählt
-   Einzelne Spalte/Variable auswählen: `m[, 3]` -\> dritte Spalte/Variable, keine Zeile/Beobachtung ausgewählt
-   Alternative für Spalten/Variablen, wenn das Objekt ein data fram ist: `df$$Var1` -\> Spalte/Variable genannt "Var1" ausgewählt
-   Je nach benutztem Paket sind andere Schreibweisen möglich, z.B. bei Benutzung von Paketen aus dem "Tidyverse" (siehe @sec-tidyverse)

## Importieren von Daten

-   Für uns sind am ehesten "klassische" Datensätze relevant - Spalten sind Variablen - Zeilen sind Beobachtungen / Fälle
-   Je nach Dateiformat sind zum Import Pakete notwendig (oder zumindest hilfreich)
-   Manuell / quick and dirty: Unten rechts den entsprechenden Ablageordner suchen -\> Klicken -\> "Import dataset"

![Datenimport eines CSV via Menu](images/image-874524877.png){#fig-datenimport-menu}

-   Oder - besser (Reproduzierbarkeit!) - via Code: Unterschiedlich je nach Datenformat.

```{r, echo = TRUE}
# csv
Churn <- readr::read_table(here("Daten", "Churn.csv"))

# txt
Arrivals <- readr::read_table(here("Daten", "Arrivals.txt"))

# Excel
alpenquer <- readxl::read_excel(here("Daten", "Alpenquerender_Gueterverkehr_Schiene.xls"))

# rda (eigenes R-Format)
load(here("Daten", "Treibstoffpreise_CH.rda"))
# Daten müssen hier keinem Objekt mehr zugewiesen werden!
```

-   Import von SPSS- oder STATA-Daten mit dem Paket `haven`
    -   **Achtung**: R geht mit Labels ganz anders um, können ggf. nicht importiert werden!

```{r}
# Import von SPSS
car_sales <- haven::read_spss(here("Daten", "car_sales.sav"))
```

## Dimensionen und Eigenschaften von Matrizen und data frames

-   Informationen über geladene Daten / Objekte erhalten
-   Hier mit den von R bereitgestellten Daten "iris": Laden mit `data(iris)` (Information zu Schwertlilien)

```{r, echo = TRUE}
data("iris")
View(iris)
str(iris) # Datentypen
```

```{r, echo = TRUE}
dim(iris)
nrow(iris) # Anzahl Fälle / Reihen
ncol(iris) # Anzahl Variablen / Spalten
length(iris) 
# Anzahl Variablen / Spalten (ACHTUNG: in diesem Fall, bei Vektoren gibt es die Länge des Vektors!)
class(iris)
head(iris) # Zeigt erste 6 Beobachtungen
tail(iris) # Zeigt letzte 6 Beobachtungen
summary(iris)
```

# Analysen

## Einfache deskriptive Statistiken

```{r, echo = TRUE}
# Mittelwert von Sepal.Length in iris
mean(iris$Sepal.Length)

# Mittelwert als Objekt abspeichern
sepal_length_mean <- mean(iris$Sepal.Length)
sepal_length_mean

# Ditto Median
sepal_length_median <- median(iris$Sepal.Length)
sepal_length_median

# Einfache Zusammenfassung der Variable
summary(iris$Sepal.Length)
```

-   Alternative z.B. mit dem Paket {vtable}

```{r, echo = TRUE}
# Zusammenfassung der Variablen (inkl. Klasse)
vtable:::vtable(iris)

# Summary statistics
vtable:::sumtable(iris)

# Summary statistics, getrennt nach "Species"
vtable:::sumtable(iris,
                  group = 'Species', # summary statistics groupiert nach Variable "Species"
                  group.test = TRUE) # Zeigt statistische Signifikanztests zwischen den Gruppen
```

## Einfache Häufigkeiten

-   Einfache Häufigkeitstabellen sind in R nicht gleich einfach wie in SPSS (siehe @sec-schwaechen)

```{r, echo = TRUE}
# Mit Basisfunktion "table"
table(iris$Species)
```

-   Alternative mit Paket {janitor}

```{r}
janitor::tabyl(iris$Species)

# Alternative Schreibweise mit tidyverse-Stil
iris |> 
  janitor::tabyl(Species)
```

## Kreuztabellen

```{r}
# Daten laden
data("ToothGrowth") # Load training data "Toothgrowth" (from guinea pigs)

table(ToothGrowth$supp, ToothGrowth$dose)
```

# Abbildungen

-   Einfache Abbildungen lassen sich mit dem {graphics}-Paket erstellen, welches in base R integriert ist
-   Mehr Individualisierung mit Paket `ggplot2` (@sec-ggplot)
-   Manchmal erkennt R die Daten auch automatisch und macht den richtigen Plot, z.B. macht `plot(iris)` automatisch einen pairs-Plot (weil der ganze Datensatz angegeben wurde; @fig-iris-pairs), `plot(iris$Species)` macht automatisch ein Säulendiagramm der Variable "Species" (@fig-iris-species)
-   Möglichkeit, die Abbildungen gleich zu exportieren und in einem Ordner zu speichern (für Benutzung in einer anderen Anwendung)
    -   Manuell (@fig-plot-export-manual)
    -   Bei ggplot2-Abbildungen mit Code: `ggsave(here("Abbildungen", "pairs-plot-iris.png"))` -\> speichert im Unterordner "Abbildungen" des Projektes (@sec-projekte!) die Abbildung im png-Format

![Manuelles Speichern / Exportieren von Abbildungen](images/Screenshot%20(43).png){#fig-plot-export-manual}

## Histogramm

-   Dazu weitere Beschriftungen mit `xlab` (Label der X-Achse), `ylab` und `main`.
-   Weitere Elemente lassen sich ergänzen (`abline(h, ...)` erstellt eine horizontale Linie)

```{r, echo = TRUE}
#| label: fig-iris-hist-sepallength
#| fig-cap: "Histogramm Sepal Length mit Mittelwert (rot)"


hist(iris$Sepal.Length,
     xlab = "Länge in cm",
     ylab = "Häufigkeit",
     main = "Sepal Length")

# Horizontale Linie einfügen
abline(h = mean(iris$Sepal.Length), # Höhe der Linie = Mittelwert 
       col="red", # Farbe der Linie
       lwd = 2) # Dicke des Striches
```

## Boxplot

-   Für mehr Übersichtlichkeit Code umbrechen!
-   Zwei Variablen mit Tilde (\~) trennen

```{r, echo = TRUE}
#| label: fig-iris-boxplot-sepallength
#| fig-cap: "Boxplot Sepal Length"

# Erste Schreibweise, Data nicht explizit zugewiesen
boxplot(iris$Sepal.Length,
        ylab = "Länge in cm",
        main = "Sepal Length")

```

```{r}
#| label: fig-iris-boxplot-sepallength-species
#| fig-cap: "Boxplot Sepal Length nach Species"

boxplot(Sepal.Length ~ Species,
        data = iris, # Andere Schreibweise, Data explizit zugewiesen
        ylab = "Länge in cm",
        xlab = "Species",
        main = "Sepal Length nach Species")
```

## Streudiagramm

-   Metrische Variablen gegeneinander
-   Dritte Variable ("Species") als Farbe
-   Keine Legende standardmässig, muss manuell erstellt werden und ist nicht sehr intuitiv (weil zwei getrennte Objekte erstellt werden ("plot" und "legend"), müssen die Farben aufeinander abgestimmt werden!)

```{r}
#| label: fig-iris-scatter-sepal-petal
#| fig-cap: "Streudiagramm Sepal Length gegen Petal Length"

plot(x = iris$Sepal.Length,
     y = iris$Petal.Length,
     xlab = "Sepal Length",
     ylab = "Petal Length",
     main = "Streudiagramm Sepal Length gegen Petal Length",
     col = iris$Species, # Punkte gefärbt nach Species
     pch = 20) # Schwarze Punkte statt leere Kreise

legend("bottomright", # legende ist unten rechts
       lty = 1, # definiert die Linienart der Legende
       col = c("black", "red", "lightgreen"),
       legend = c("setosa", 
               "versicolor",
               "virginica"))
```

-   Reihenfolge und Farbe der Legende muss manuell mit den Kategorien und Farben in der Abbildung abgestimmt werden!
-   Beim genauen Hinsehen stimmen die Farben nicht 1:1 überein!

## Pairs

-   Ersten Überblick gewinnen, nicht zu viele Variablen gleichzeitig!
-   Wenig sinnvoll bei nicht-metrische Variablen (siehe "Species")

```{r, echo = TRUE}
#| label: fig-iris-pairs-all
#| fig-cap: "Pairs-plot aller Variablen in iris"

# Alle Variablen von iris
pairs(iris)
```

-   Kategoriale Variable "Species" mach hier weniger Sinn, zudem wird der Plot zu gross bei zu vielen Variablen -\> Variablen einschränken für Plot

```{r}
#| label: fig-iris-pairs-numerical
#| fig-cap: "Pairs-plot der numerischen Variablen in iris"


# Befehl eingeschränkt auf Spalten 1:4 von iris 
# (und alle Zeilen, keine Eingabe vor Komma)
pairs(iris[,1:4])
```

## Säulendiagramme

-   Speziell, weil für die `barplot()`-Funktion zuerst eine Häufigkeitstabelle gebildet werden muss (einfacher mit `plot()`, siehe @sec-abb-plot)

```{r}
#| label: fig-iris-barplot-species
#| fig-cap: "Säulendiagramm Species"

barplot(table(iris$Species))
```

## Standard-Plot (inkl. Streudiagramm) {#sec-abb-plot}

-   Die Standardfunktion `plot()` erkennt je nachdem auch automatisch, wie die Zieldaten aussehen und erstellt selständig eine passende Abbildung dazu
    -   `plot(df)` -\> alle Variablen des Datensatzes, ergibt einen pairs-Plot (@fig-iris-pairs)
    -   `plot(df$Var1)` -\> Variable 1 des Datensatzes, ergibt z.B. bei kategorialen Variablen ein Säulendiagramm (@fig-iris-species)
    -   `plot(df$Var1, df$Var2)` -\> Variable 1 und Variable 2 des Datensatzes zusammen, ergibt bei numerischen Variablen einen Scatterplot (@fig-iris-sepalwidth-sepallength)

```{r}
#| label: fig-iris-pairs
#| fig-cap: "Pairs-Plot aller Variablen in iris"

plot(iris)
```

```{r}
#| label: fig-iris-species
#| fig-cap: "Säulendiagramm 'Species'"

plot(iris$Species)
```

```{r}
#| label: fig-iris-sepalwidth-sepallength
#| fig-cap: "Streudiagramm Sepal Width - Sepal Length"

plot(iris$Sepal.Width, iris$Sepal.Length)
```

# Schwächen von R (zumindest im Vergleich zu SPSS) {#sec-schwaechen}

-   Keine Labels
-   Umgang mit fehlenden Werte
-   Gewichtung von Daten?
-   Pakete können umgeschrieben werden, Code kann sich ändern
-   Einfache Häufigkeits- und Kreuztabellen mit Prozenten sind nicht gleich schnell

# Weitere Objekte

## Resultate von Analysen

-   Objekte in R müssen nicht zwingend Zahlen oder Datensätze sein. Als Objekte können auch gespeichert werden:
    -   Resultate von Analysen
    -   Zeitreihen
    -   Listen
    -   etc.

```{r}
# Einfache lineare Regression
fit_iris <- lm(Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width, data = iris)

# Zusammenfassung des Modells
summary(fit_iris)

plot(fit_iris$residuals)
plot(fit_iris$coefficients)
```

-   Auf einzelne Objekte der Resultate kann wiederum zugegriffen werden

```{r}
fit_iris$coefficients
```

## Zeitreihen

-   Sieht ähnlich aus wie normaler Datensatz, ist aber für R als Zeitreihe erkennbar

```{r}
# Zeitreihe
data("AirPassengers")
AirPassengers
str(AirPassengers)
```

# Wo finde ich Hilfe?

-   bibs\@zhaw.ch
-   Google
-   R-Hilfe: In der Konsole mit Fragezeichen den Begriff eingeben, z.B. `?median` (@fig-help-median}), `?boxplot` (@fig-help-boxplot) oder `?filter` (@fig-help-filter).

![Hilfe zu median (Paket {stats})](images/Screenshot%20(37).png){#fig-help-median}

![Hilfe zu boxplot (Paket {graphics})](images/Screenshot%20(36).png){#fig-help-boxplot}

![Hilfe zu filter (zwei Pakete; davon das gewünschte Auswählen)](images/Screenshot%20(38).png){#fig-help-filter}

-   Die Tidyverse-Bibel: <https://r4ds.hadley.nz/> (siehe @sec-tidyverse)
-   <https://rstudio.github.io/r-manuals/>

# Weiterführendes

## R-Skript vs. Markdown / Quarto

-   Skripte für reine Analysen, Text muss (analog zu SPSS-Syntax) auskommentiert werden mit *\#*
-   Skripte strukturieren mit vier Trennstrichen `----` am Ende des Titels

```{r}
1 + 1 # Code auskommentieren mit hashtag

# Mittelwert der Zahlen 1, 2, 3, 4 berechnen
mean(c(1,2,3,4))

# Gleiches Resultat
mean(1:4)
```

-   Markdown / Quarto: Primär Text-Dokumente, Code muss eingefügt werden in sogenannten "Chunks" (in Quarto sind auch Chunks für Python und andere Sprachen möglich!)
    -   Analysen können auch inline im Text eingebaut werden, z.B. ergibt die Eingabe des Codes `"r (mean(iris$Sepal.Width)) + (median(ToothGrowth$len))"` im Text direkt das Resultat dieser Berechnung (`r (mean(iris$Sepal.Width)) + (median(ToothGrowth$len))`) im Text wieder. D.h. Berechnungen lassen dich direkt in den Text eines Berichts einbauen; wenn sich die Daten verändern, kann der Bericht automatisiert neu erstellt werden und die neu gültigen Zahlen werden automatisch angepasst im Bericht
    -   Das gleiche gilt für im Bericht eingebaute Abbildungen, diese müssen nicht angepasst werden bei veränderten Daten
    -   Erstellen von Publikationen direkt in RStudio (zum Beispiel dieses Dokument)
    -   Betrieben von Posit, die auch RStudio betreiben -\> Open Source
    -   <https://quarto.org/>
    -   Kann auch in anderen Programmen betrieben werden (z.B. VS Code)
    -   Output in div. Formaten möglich (Word, PDF, Folien, HTML)
    -   Kein Copy/Paste von SPSS zu Excel zu Word!
    -   Hat visuellen Editor (@fig-quarto-visual-editor)!

![Quarto: Visueller Editor](images/Screenshot%20(41).png){#fig-quarto-visual-editor}

-   Python funktioniert ähnlich, aber anders als R, siehe folgender Chunk (aber die Ausgabe in diesem Dokument scheint leicht anderer Logik zu folgen als bei einem R-Chunk)
-   Code oben ist in R, unten in Python

```{python}
# Statistikpaket für python laden
import statistics

# Daten definieren
data1 = [1, 3, 4, 5, 7, 9, 2]

# Mittelwert ausrechnen
statistics.mean(data1)

# Auch mit python können in RStudio Objekte definiert werden
x = statistics.mean(data1)

# x ausgeben
x

# Printen mit Text
print("Mean is:", x)
```

## Tidyverse {#sec-tidyverse}

-   Meist verbreitetes Paket für Datenaufbereitung, -analyse und -visualisierung
-   Eigene Syntaxstruktur, aufbauend / hintereinander verknüpft, weniger verschachtelt als base R (wo man beim lesen mehrerer Funktionen "von innen" anfangen muss):
    1.  Welche Daten sollen benutzt werden?
    2.  Was soll damit gemacht werden?
    3.  Verketten mit dem "Pipe"-Operator (`|>`, früher `%>%`); bedeutet sozusagen "dann mach das..."
-   Codebeispiel für base R und tidyverse: Im iris-Datensatz die Species "virginica" filtern und daraus eine neue Variable bilden mit der Summe aus "Sepal Length" und "Sepal Width", diese Daten neu abspeichern

```{r}
# Ganzes Tidyverse laden
library(tidyverse)
# Daten laden
data("iris")

# Mit base R
virginica_base <- transform(subset(iris, 
                                   Species == "virginica"),
                            sepallength_width = (Sepal.Length + Sepal.Width),
                            petallength_width = (Petal.Length + Petal.Width))

View(virginica_base)

# Mit tidyverse
virginica_tidy <- iris |> 
  filter(Species == "virginica") |> # 
  mutate(sepallength_width = (Sepal.Length + Sepal.Width)) |>   # Berechne die Summe aus "Sepal.Length" und "Sepal.Width" und nenne die neue Variable "sepallength_width"
  mutate(petallength_width = (Petal.Length + Petal.Width))

View(virginica_tidy)

# Randnotiz: Tidyverse beginnt die Zeilennummerierung wieder bei 1, mit base R bleibt die Zeilennummerierung wie im ursprünglichen Datensatz, fängt bei 101 an
```

-   Zusammengesetzt aus verschiedenen Paketen (tidyverse = ganzes Universum), je nach Bedürfnis können auch nur einzelne Pakete geladen werden
    -   {ggplot2} (gg = Grammar of Graphics, siehe @sec-ggplot)

    -   {tidyr}: Daten bereinigen / Umformatieren

    -   {dplyr}: Datenmanipulation

    -   {readr}: Daten einlesen in verschiedenen Formaten

    -   {string}: Umgang mit string-Variablen

    -   {forcats}: Umgang mit kategoriellen Variablen

    -   etc. ...
-   Nutzung
    -   `library(tidyverse)`: Lädt ganzes Universum (alle Pakete)
    -   `library(ggplot)`: Lädt nur Paket "ggplot2"
-   <https://www.tidyverse.org/>
-   Open source Lehrbuch zum Tidyverse: "[R for Data Science](https://r4ds.had.co.nz/)" von Wickham und Grolemund (Hadley Wickham ist Chief Scientist bei Posit, der Firma, die RStudio betreibt)

## ggplot2 {#sec-ggplot}

-   Paket zur Datenvisualisierung, Teil des "Tidyverse"-Universum
-   Gleiche Syntaxlogik wie andere "Tidyverse"-Pakete
-   **Viele** Einstellungsmöglichkeiten bei Abbildungen, siehe z.B. @fig-iris-sepallength-histogram-ggplot, @fig-iris-sepallength-histogram-ggplot-facet oder @fig-iris-sepallength-histogram-ggplot-identity

```{r, echo = TRUE}
#| label: fig-iris-sepallength-histogram-base
#| fig-cap: "Histogramm Sepal Length mit base R"


hist(iris$Sepal.Length,
     xlab = "Länge in cm",
     ylab = "Häufigkeit",
     main = "Sepal Length (mit Base R)")
```

```{r}
#| label: fig-iris-sepallength-histogram-ggplot
#| fig-cap: "Histogramm Sepal Length mit ggplot2"

library(ggplot2)
# Variante 1 mit ggplot2
ggplot(iris) +
    aes(x = Sepal.Length) +
    geom_histogram() +
    labs(
        x = "Länge in cm",
        y = "Häufigkeit",
        main = "Sepal Length (mit ggplot, Var. 1)"
    )
```

```{r}
#| label: fig-iris-sepallength-histogram-ggplot-facet
#| fig-cap: "Histogramm Sepal Length mit ggplot2, aufgeteilt nach Species"

library(ggplot2)

# Variante 2 mit ggplot2
ggplot(iris) +
    aes(x = Sepal.Length) +
    geom_histogram(binwidth = 0.2) +
    facet_wrap(~ Species) +
    labs(
        x = "Länge in cm",
        y = "Häufigkeit",
        main = "Sepal Length (mit ggplot, Var. 2)"
    )
```

```{r}
#| label: fig-iris-sepallength-histogram-ggplot-identity
#| fig-cap: "Histogramm Sepal Length mit ggplot2, Species überlagernd"

# Variante 3 mit ggplot2
ggplot(iris) +
    aes(x = Sepal.Length, 
        fill = Species) +
    geom_histogram(binwidth = 0.2,
                   alpha = 0.5, # Durchsichtigkeit der Säulen
                   position = "identity") + # Überlagerung der Säulen
    theme_minimal() +
    labs(
        x = "Länge in cm",
        y = "Häufigkeit",
        main = "Sepal Length (mit ggplot, Var. 3)"
    )
```

## Git und github {#sec-github}

-   System zur Kollaboration an Code und Versionsontrolle
-   Aus Software Center "Git" installieren
-   Ist in RStudio integriert (oben rechts "Git"), braucht kein weitere Programm
-   <https://github.com> resp. eigene Version für ZHAW: <https://github.zhaw.ch/>
-   Einführung speziell für R z.B. hier: <https://happygitwithr.com/index.html>
-   Im Intranet der ZHAW: <https://zhaw.sharepoint.com/:b:/r/sites/osc/Freigegebene%20Dokumente/2021_10_27%20-%20Git%20why%20and%20how.pdf?csf=1&web=1&e=2EehhW> oder <https://intra.zhaw.ch/departemente/school-of-engineering/services/dienste-tools/soe-it-infrastruktur/git-umgebung/>

## Shiny

-   App zur Datenvisualisierung, -simulation etc.
-   Kann in RStudio ausgeführt werden, aber auch in Homepages eingebaut werden
-   Infos hier: <https://shiny.rstudio.com/tutorial/> und hier <https://mastering-shiny.org/>
-   Siehe `app.R` -\> Öffnen in RStudio -\> Oben rechts auf "Run App" klicken
